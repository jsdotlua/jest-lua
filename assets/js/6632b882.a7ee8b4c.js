"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[556],{3877:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var s=n(4848),i=n(8453);const r={id:"upgrading-to-jest3",title:"From v2.x to v3.x"},o=void 0,l={id:"upgrading-to-jest3",title:"From v2.x to v3.x",description:"Upgrading Jest Lua from v2.x or TestEZ to v3.x? This guide aims to help refactoring your configuration and tests.",source:"@site/docs/UpgradingToJest3.md",sourceDirName:".",slug:"/upgrading-to-jest3",permalink:"/jest-lua/upgrading-to-jest3",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"upgrading-to-jest3",title:"From v2.x to v3.x"},sidebar:"docs",previous:{title:"Migrating from TestEZ",permalink:"/jest-lua/testez-migration"},next:{title:"Deviations",permalink:"/jest-lua/deviations"}},a={},c=[{value:"Migration",id:"migration",level:2},{value:"Setup",id:"setup",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Updating Tests",id:"updating-tests",level:3},{value:"Running Tests",id:"running-tests",level:3},{value:"Notable Differences",id:"notable-differences",level:2},{value:"FOCUS and SKIP",id:"focus-and-skip",level:3},{value:"Setup",id:"setup-1",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Upgrading Jest Lua from v2.x or TestEZ to v3.x? This guide aims to help refactoring your configuration and tests."}),"\n",(0,s.jsx)(t.h2,{id:"migration",children:"Migration"}),"\n",(0,s.jsx)(t.h3,{id:"setup",children:"Setup"}),"\n",(0,s.jsxs)(t.p,{children:["First, update your ",(0,s.jsx)(t.code,{children:"wally.toml"})," to use Jest Lua v3.0. You'll also need to require the ",(0,s.jsx)(t.code,{children:"Jest"})," package in addition to the ",(0,s.jsx)(t.code,{children:"JestGlobals"})," package. The ",(0,s.jsx)(t.code,{children:"Jest"})," package contains ",(0,s.jsx)(t.code,{children:"runCLI"}),", which is the main entrypoint into Jest Lua in v3.0."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",metastring:'title="rotriever.toml"',children:'[dev-dependencies]\nJest = "jsdotlua/jest@3.6.1-rc.2"\nJestGlobals = "jsdotlua/jest-globals@3.6.1-rc.2"\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Update your ",(0,s.jsx)(t.code,{children:"spec.lua"}),". Instead of using ",(0,s.jsx)(t.code,{children:"TestEZ.TestBootStrap:run"}),", the main entrypoint is now ",(0,s.jsx)(t.code,{children:"Jest.runCLI"}),". A basic bootstrap script can look like the following:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",metastring:'title="spec.lua"',children:'local YourProject = script.Parent.YourProject\nlocal runCLI = require("@DevPackages/Jest").runCLI\n\nlocal processServiceExists, ProcessService = pcall(function()\n\treturn game:GetService("ProcessService")\nend)\n\nlocal status, result = runCLI(YourProject.Source, {\n\tverbose = false,\n\tci = false\n}, { YourProject.Source }):awaitStatus()\n\nif status == "Rejected" then\n\tprint(result)\nend\n\nif status == "Resolved" and result.results.numFailedTestSuites == 0 and result.results.numFailedTests == 0 then\n\tif processServiceExists then\n\t\tProcessService:ExitAsync(0)\n\tend\nend\n\nif processServiceExists then\n\tProcessService:ExitAsync(1)\nend\n\nreturn nil\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The first argument is the root directory of your project and the third argument is a list of projects (directories with a ",(0,s.jsx)(t.code,{children:"jest.config.lua"}),") with tests for Jest Lua to discover. For a simple mono-package project, these should just point to your source directory. For detailed information, see ",(0,s.jsx)(t.a,{href:"cli",children:"runCLI Options"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsxs)(t.p,{children:["Because Jest Lua now expects that projects have a configuration file, create a ",(0,s.jsx)(t.code,{children:"jest.config.lua"})," in your source directory. A simple configuration file can just specify the paths to tests for Jest Lua to discover. For more configuration options, see ",(0,s.jsx)(t.a,{href:"configuration",children:"Configuring Jest"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",metastring:'title="jest.config.lua"',children:'return {\n\ttestMatch = { "**/*.spec" },\n}\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsx)(t.p,{children:"Currently, Jest Lua will error if no configuration file is found."})}),"\n",(0,s.jsx)(t.h3,{id:"updating-tests",children:"Updating Tests"}),"\n",(0,s.jsx)(t.p,{children:"Jest Lua v3.0 no longer relies on test files returning a callback.\nA simple test file in v2.x may look like the following:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",metastring:'title="test.spec.lua"',children:'return function()\n\tlocal JestGlobals = require("@DevPackages/JestGlobals")\n\tlocal expect = JestGlobals.expect\n\n\tit("1 does not equal 2", function()\n\t\texpect(1).toBe(2)\n\tend)\nend\n'})}),"\n",(0,s.jsx)(t.p,{children:"This test should now look like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",metastring:'title="test.spec.lua"',children:'local JestGlobals = require("@DevPackages/JestGlobals")\nlocal expect = JestGlobals.expect\nlocal it = JestGlobals.it\n\nit("1 does not equal 2", function()\n\texpect(1).toBe(2)\nend)\n'})}),"\n",(0,s.jsx)(t.p,{children:"There are a couple interesting differences:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Jest Lua v3.0 no longer relies on test files returning a callback so the test file does not need to be wrapped in a callback function."}),"\n"]}),"\n",(0,s.jsxs)(t.admonition,{type:"tip",children:[(0,s.jsx)(t.p,{children:"Jest Lua v2.x required that all test modules return a function with test contents. In Jest Lua v3.0.0 - v3.1.1, test modules no longer relied on a wrapping function, but still expected a non-nil return."}),(0,s.jsx)(t.p,{children:"As of Jest Lua v3.1.1, test modules are treated specially and are no longer expected to return any value."})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["In addition to ",(0,s.jsx)(t.code,{children:"expect"}),", ",(0,s.jsx)(t.code,{children:"it"})," is also imported from ",(0,s.jsx)(t.code,{children:"JestGlobals"}),". Unlike TestEZ or Jest Lua v2.x, no values are magically injected into the environment."]}),"\n"]}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["Any value you need must be explicitly imported from ",(0,s.jsx)(t.code,{children:"JestGlobals"}),", including common ones like ",(0,s.jsx)(t.code,{children:"describe"})," or ",(0,s.jsx)(t.code,{children:"it"}),". Jest Lua ",(0,s.jsx)(t.strong,{children:"will"})," error if these values are not imported. To see a full list of values exported in ",(0,s.jsx)(t.code,{children:"JestGlobals"}),", see ",(0,s.jsx)(t.a,{href:"api",children:"Globals"}),"."]})}),"\n",(0,s.jsx)(t.h3,{id:"running-tests",children:"Running Tests"}),"\n",(0,s.jsxs)(t.p,{children:["Jest Lua v3.0 also requires the fast flag ",(0,s.jsx)(t.code,{children:"EnableLoadModule"}),". This must be added to your Roblox Studio ",(0,s.jsx)(t.code,{children:"ClientAppSettings.json"})," file:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",metastring:'title="ClientAppSettings.json"',children:'{\n\t"FFlagEnableLoadModule": true\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"notable-differences",children:"Notable Differences"}),"\n",(0,s.jsx)(t.h3,{id:"focus-and-skip",children:"FOCUS and SKIP"}),"\n",(0,s.jsxs)(t.p,{children:["Instead of ",(0,s.jsx)(t.code,{children:"FOCUS"}),", ",(0,s.jsx)(t.code,{children:"SKIP"})," in v2.x, v3.0 uses the ",(0,s.jsx)(t.code,{children:".only"})," and ",(0,s.jsx)(t.code,{children:".skip"})," operator. These behave differently from their equivalents in v2.x due to the changes in the test runner."]}),"\n",(0,s.jsx)(t.p,{children:"In v3.0, the test runner discovers and runs every test file independently so each test file is considered a test suite. This is different from the test runner in v2.x, which first discovers every test and generates a test plan before running everything as a single suite."}),"\n",(0,s.jsxs)(t.p,{children:["This means that the ",(0,s.jsx)(t.code,{children:".only"})," and ",(0,s.jsx)(t.code,{children:".skip"})," operator ",(0,s.jsx)(t.strong,{children:"only"})," affect the test file that they are in, not the entire test run (i.e. marking a test as ",(0,s.jsx)(t.code,{children:".only"})," will run only that test in that file, but will still run every test in every other file)."]}),"\n",(0,s.jsxs)(t.admonition,{type:"tip",children:[(0,s.jsxs)(t.p,{children:["You may use test filtering configuration options or ",(0,s.jsx)(t.code,{children:"runCLI"})," options to run only specific test files or specific tests."]}),(0,s.jsx)(t.p,{children:"For example, given this test:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",metastring:'title="peanutButter.spec.lua"',children:"test('the data is peanut butter', function()\n    -- ...\nend)\n"})}),(0,s.jsxs)(t.p,{children:["To run only that test file, use the ",(0,s.jsx)(t.code,{children:"testMatch"})," configuration option. Set ",(0,s.jsx)(t.code,{children:'testMatch = { "**/peanutButter.spec" }'})," in either ",(0,s.jsx)(t.code,{children:"runCLI"})," or your ",(0,s.jsx)(t.code,{children:"jest.config.lua"}),". You can then use ",(0,s.jsx)(t.code,{children:"test.only"})," to run only that test."]}),(0,s.jsxs)(t.p,{children:["To run only tests with a specific name, you may pass the ",(0,s.jsx)(t.code,{children:"testNamePattern"})," into ",(0,s.jsx)(t.code,{children:"runCLI"}),". For example, to run only this test, you can pass ",(0,s.jsx)(t.code,{children:'testNamePattern = "the data is peanut butter"'})," into ",(0,s.jsx)(t.code,{children:"runCLI"}),"."]}),(0,s.jsxs)(t.p,{children:["See ",(0,s.jsx)(t.a,{href:"configuration",children:"Configuring Jest"})," or ",(0,s.jsx)(t.a,{href:"cli",children:"runCLI Options"})," for other options to filter test runs."]})]}),"\n",(0,s.jsx)(t.h3,{id:"setup-1",children:"Setup"}),"\n",(0,s.jsx)(t.p,{children:"Some v2.x tests use the test callbacks to set up an environment (Roact components for example) and pass state into a test file. In v3.0, test files are run separately in their own environment so state cannot be shared or passed around to a test file."}),"\n",(0,s.jsxs)(t.p,{children:["Every test file must set up its own state or imported from a file explicitly with a ",(0,s.jsx)(t.code,{children:"require"}),". This may make some setup more verbose or cumbersome, but makes dependencies much more explicit and improves readability and makes tests much easier to debug."]}),"\n",(0,s.jsxs)(t.p,{children:["However, some setup can be shared across test files sharing a configuration with the ",(0,s.jsx)(t.a,{href:"configuration#setupfilesafterenv-arraymodulescript",children:(0,s.jsx)(t.code,{children:"setupFilesAfterEnv"})})," option. This is useful for adding custom matchers or custom serializers, or for calling setup and teardown hooks that need to be shared across tests."]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var s=n(6540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);