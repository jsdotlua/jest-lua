"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[353],{1983:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var s=n(4848),o=n(8453);const r={id:"testez-migration",title:"Migrating from TestEZ"},i=void 0,a={id:"testez-migration",title:"Migrating from TestEZ",description:"If you are using TestEZ, migrating to Jest Lua v2.4.x should be fairly straightforward. Many parts of Jest Lua v2.x still use the TestEZ API.",source:"@site/docs/TestEZMigration.md",sourceDirName:".",slug:"/testez-migration",permalink:"/jest-lua/testez-migration",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"testez-migration",title:"Migrating from TestEZ"},sidebar:"docs",previous:{title:"Timer Mocks",permalink:"/jest-lua/timer-mocks"},next:{title:"From v2.x to v3.x",permalink:"/jest-lua/upgrading-to-jest3"}},c={},l=[{value:"<code>.to.equal(value)</code>",id:"toequalvalue",level:3},{value:"<code>.to.be.ok()</code>",id:"tobeok",level:3},{value:"<code>.to.be.near(value)</code>",id:"tobenearvalue",level:3},{value:"<code>.to.be.a(type)</code>",id:"tobeatype",level:3},{value:"<code>.to.throw()</code>",id:"tothrow",level:3},{value:"<code>.extend(matchers)</code>",id:"extendmatchers",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["If you are using ",(0,s.jsx)(t.a,{href:"https://github.com/Roblox/testez",children:"TestEZ"}),", migrating to Jest Lua v2.4.x should be fairly straightforward. Many parts of Jest Lua v2.x still use the TestEZ API."]}),"\n",(0,s.jsxs)(t.p,{children:["To migrate to Jest Lua v3.x, additionally see ",(0,s.jsx)(t.a,{href:"upgrading-to-jest3",children:"upgrading to Jest Lua v3"}),"."]}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["The community Jest Lua fork has not published ",(0,s.jsx)(t.code,{children:"v2.x"}),". Migrating straight from TestEZ to Jest Lua ",(0,s.jsx)(t.code,{children:"v3.x"})," requires following this guide and then ",(0,s.jsx)(t.a,{href:"upgrading-to-jest3",children:"upgrading to Jest Lua v3"}),"."]})}),"\n",(0,s.jsxs)(t.p,{children:["Replace ",(0,s.jsx)(t.code,{children:"TestEZ"})," with ",(0,s.jsx)(t.code,{children:"JestGlobals"})," in your ",(0,s.jsx)(t.code,{children:"Wally.toml"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-diff",metastring:'title="wally.toml"',children:'[dev-dependencies]\n- TestEZ = "roblox/testez@0.4.1"\n+ JestGlobals = "jsdotlua/jest-globals@3.6.1-rc.2"\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Unlike TestEZ, which is injected into the global environment, you will need to explicitly require anything you need from ",(0,s.jsx)(t.code,{children:"JestGlobals"}),". For example, to use the new Jest Lua assertion library, add this to the top of your test file."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'local JestGlobals = require("@DevPackages/JestGlobals")\nlocal expect = JestGlobals.expect\n'})}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsx)(t.p,{children:"Globals that are injected make life very difficult for languages with strong types \u2014 because there's no specific import, and the code artifact injecting the globals can change underneath hard-coded type signatures, it requires inefficient tooling and workarounds."}),(0,s.jsxs)(t.p,{children:["Additionally, upstream Jest also plans to remove injected globals and instead prefers that users import any needed functionality through the ",(0,s.jsx)(t.code,{children:"@jest/globals"})," package."]}),(0,s.jsxs)(t.p,{children:["Jest Lua is staying ahead of that plan and not including support for injected globals. In Jest Lua v3.x, ",(0,s.jsx)(t.em,{children:"every"})," import will need to be explicitly required, including ",(0,s.jsx)(t.code,{children:"describe"}),", ",(0,s.jsx)(t.code,{children:"it"}),", etc. See ",(0,s.jsx)(t.a,{href:"api",children:"Globals"})," for a list of all exports."]}),(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://jestjs.io/blog/2020/05/05/jest-26#a-new-way-to-consume-jest---jestglobals",children:"https://jestjs.io/blog/2020/05/05/jest-26#a-new-way-to-consume-jest---jestglobals"})})]}),"\n",(0,s.jsxs)(t.p,{children:["If you were previously overwriting the Luau type for ",(0,s.jsx)(t.code,{children:"expect"})," as a workaround for TestEZ custom expectations, you can remove it."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-diff",children:"-local expect: any = expect\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Then, replace the TestEZ ",(0,s.jsx)(t.code,{children:"expect"})," syntax with their equivalents in Jest Lua. The equivalent matchers for each TestEZ matcher are listed below."]}),"\n",(0,s.jsxs)(t.p,{children:["The new Jest Lua matchers are much more powerful than their TestEZ equivalents so see the ",(0,s.jsx)(t.a,{href:"expect",children:"reference doc"})," for more advanced usage, and also see all the new matchers Jest Lua has to offer."]}),"\n",(0,s.jsx)(t.h3,{id:"toequalvalue",children:(0,s.jsx)(t.code,{children:".to.equal(value)"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:".to.equal(value)"})," method does a strict equality check, which exists in Jest Lua as ",(0,s.jsx)(t.code,{children:".toBe(value)"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-diff",children:"- expect(1).to.equal(1)\n+ expect(1).toBe(1)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This is different from the ",(0,s.jsx)(t.code,{children:".toEqual"})," matcher in Jest Lua, which does a recursive deep equality check. For example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"expect({a = 1}).to.equal({a = 1}) -- fails in TestEZ\nexpect({a = 1}).toBe({a = 1})     -- fails in Jest Lua, but warns you\nexpect({a = 1}).toEqual({a = 1})  -- passes in Jest Lua\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tobeok",children:(0,s.jsx)(t.code,{children:".to.be.ok()"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:".to.be.ok()"})," is a ",(0,s.jsx)(t.code,{children:"nil"})," check, which is ",(0,s.jsx)(t.code,{children:".never.toBeNil()"})," in Jest Lua."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-diff",children:"- expect(1).to.be.ok()\n+ expect(1).never.toBeNil()\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tobenearvalue",children:(0,s.jsx)(t.code,{children:".to.be.near(value)"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:".to.be.near(value)"})," is used to compare floating point numbers for approximate equality. In Jest Lua, it is ",(0,s.jsx)(t.code,{children:".toBeCloseTo(number, numDigits?)"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-diff",children:"- expect(0.1 + 0.2).to.be.near(0.3)\n+ expect(0.1 + 0.2).toBeCloseTo(0.3)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tobeatype",children:(0,s.jsx)(t.code,{children:".to.be.a(type)"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:".to.be.a(type)"})," is used to do type checking. Type checking in Jest Lua is done using the ",(0,s.jsx)(t.code,{children:".toEqual()"})," matcher with ",(0,s.jsx)(t.code,{children:"expect.any(type)"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-diff",children:'- expect(1).to.be.a("number")\n+ expect(1).toEqual(expect.any("number"))\n'})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.any()"})," is an asymmetric matcher, which can be used for much more than just checking primitive types like this. See the reference doc on ",(0,s.jsx)(t.a,{href:"expect#expectanytypename--prototype",children:(0,s.jsx)(t.code,{children:"expect.any()"})}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"tothrow",children:(0,s.jsx)(t.code,{children:".to.throw()"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:".to.throw()"})," can be replaced with ",(0,s.jsx)(t.code,{children:".toThrow()"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-diff",children:'expect(function()\n\terror("nope")\n- end).to.throw()\n+ end).toThrow("nope")\n'})}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.code,{children:".toThrow()"})," with no arguments will match against any exception, so it is recommended to match against a specific error message or use the ",(0,s.jsx)(t.a,{href:"expect#error",children:(0,s.jsx)(t.code,{children:"Error"})})," polyfill to throw and match against a specific exception. See the reference doc on ",(0,s.jsx)(t.a,{href:"expect#tothrowerror",children:(0,s.jsx)(t.code,{children:".toThrow(error?)"})}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"extendmatchers",children:(0,s.jsx)(t.code,{children:".extend(matchers)"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.extend"})," takes ",(0,s.jsx)(t.code,{children:"self"})," (or ",(0,s.jsx)(t.code,{children:"_"})," if the ",(0,s.jsx)(t.code,{children:"matcherContext"})," isn't needed) as its first argument and the ",(0,s.jsx)(t.code,{children:"message"})," property in the return value must be a function. See the reference doc on the ",(0,s.jsx)(t.a,{href:"expect#custom-matchers-api",children:"custom matcher API"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-diff",children:'expect.extends({\n-\tcustomMatcher = function(arg)\n+\tcustomMatcher = function(_, arg)\n\t\treturn {\n\t\t\tpass = true,\n-\t\t\tmessage = "message",\n+\t\t\tmessage = function() return "message" end\n\t\t}\n\tend\n})\n'})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var s=n(6540);const o={},r=s.createContext(o);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);