"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[761],{7988:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>o});var a=n(4848),i=n(8453);const s={id:"timer-mocks",title:"Timer Mocks"},l=void 0,c={id:"timer-mocks",title:"Timer Mocks",description:"The Lua and Roblox native timer functions (i.e., delay(), tick(), os.time(), os.clock()) are less than ideal for a testing environment since they depend on real time to elapse. Jest Lua can swap out timers with functions that allow you to control the passage of time. Great Scott!",source:"@site/docs/TimerMocks.md",sourceDirName:".",slug:"/timer-mocks",permalink:"/jest-lua/timer-mocks",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"timer-mocks",title:"Timer Mocks"},sidebar:"docs",previous:{title:"Snapshot Testing",permalink:"/jest-lua/snapshot-testing"},next:{title:"Migrating from TestEZ",permalink:"/jest-lua/testez-migration"}},r={},o=[{value:"Enable Fake Timers",id:"enable-fake-timers",level:2},{value:"Run All Timers",id:"run-all-timers",level:2},{value:"Run Pending Timers",id:"run-pending-timers",level:2},{value:"Advance Timers by Time",id:"advance-timers-by-time",level:2},{value:"Setting Engine Frame Time",id:"setting-engine-frame-time",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("p",{children:(0,a.jsx)("a",{href:"https://jestjs.io/docs/27.x/timer-mocks",target:"_blank",children:(0,a.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})})}),"\n",(0,a.jsx)("img",{alt:"deviation",src:"img/deviation.svg"}),"\n",(0,a.jsxs)(t.p,{children:["The Lua and Roblox native timer functions (i.e., ",(0,a.jsx)(t.code,{children:"delay()"}),", ",(0,a.jsx)(t.code,{children:"tick()"}),", ",(0,a.jsx)(t.code,{children:"os.time()"}),", ",(0,a.jsx)(t.code,{children:"os.clock()"}),") are less than ideal for a testing environment since they depend on real time to elapse. Jest Lua can swap out timers with functions that allow you to control the passage of time. ",(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=QZoJ2Pt27BY",children:"Great Scott!"})]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsxs)(t.p,{children:["Also see ",(0,a.jsx)(t.a,{href:"jest-object#fake-timers",children:"Fake Timers API"})," documentation."]})}),"\n",(0,a.jsx)(t.h2,{id:"enable-fake-timers",children:"Enable Fake Timers"}),"\n",(0,a.jsxs)(t.p,{children:["In the following example we enable fake timers by calling ",(0,a.jsx)(t.code,{children:"jest.useFakeTimers()"}),". This is replacing the original implementation of ",(0,a.jsx)(t.code,{children:"task.delay()"})," and other timer functions. Timers can be restored to their normal behavior with ",(0,a.jsx)(t.code,{children:"jest.useRealTimers()"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",metastring:'title="timerGame.lua"',children:"return function(callback)\n\tprint('Ready....go!')\n\ttask.delay(1, function()\n\t\tprint(\"Time's up -- stop!\")\n\t\tif callback do\n\t\t\tcallback()\n\t\tend\n\tend)\nend\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",metastring:'title="__tests__/timerGame-test.spec.lua"',children:"local jest = JestGlobals.jest\n\njest.useFakeTimers()\n\ntest('waits 1 second before ending the game', function()\n\tlocal timerGame = require(Workspace.timerGame)\n\ttimerGame()\nend)\n"})}),"\n",(0,a.jsx)(t.h2,{id:"run-all-timers",children:"Run All Timers"}),"\n",(0,a.jsx)(t.p,{children:"Another test we might want to write for this module is one that asserts that the callback is called after 1 second. To do this, we're going to use Jest's timer control APIs to fast-forward time right in the middle of the test:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:"jest.useFakeTimers()\n\ntest('calls the callback after 1 second', function()\n\tlocal timerGame = require(Workspace.timerGame)\n\tlocal callback = jest.fn()\n\n\ttimerGame(callback)\n\n\t-- At this point in time, the callback should not have been called yet\n\texpect(callback).never.toBeCalled()\n\n\t-- Fast-forward until all timers have been executed\n\tjest.runAllTimers()\n\n\t-- Now our callback should have been called!\n\texpect(callback).toBeCalled()\n\texpect(callback).toHaveBeenCalledTimes(1)\nend)\n"})}),"\n",(0,a.jsx)(t.h2,{id:"run-pending-timers",children:"Run Pending Timers"}),"\n",(0,a.jsx)(t.p,{children:"There are also scenarios where you might have a recursive timer \u2013 that is a timer that sets a new timer in its own callback. For these, running all the timers would be an endless loop."}),"\n",(0,a.jsxs)(t.p,{children:["If that is your case, using ",(0,a.jsx)(t.code,{children:"jest.runOnlyPendingTimers()"})," will solve the problem:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",metastring:'title="infiniteTimerGame.lua"',children:"local function infiniteTimerGame(callback)\n\tprint('Ready....go!')\n\n\ttask.delay(1, function()\n\t\tprint(\"Time's up! 10 seconds before the next game starts...\");\n\t\tif callback then\n\t\t\tcallback()\n\t\tend\n\n\t\ttask.delay(10, function()\n\t\t\tinfiniteTimerGame(callback)\n\t\tend)\n\tend)\nend\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",metastring:'title="__tests__/infiniteTimerGame-test.spec.lua"',children:"jest.useFakeTimers()\n\ndescribe('infiniteTimerGame', function()\n\ttest('schedules a 10-second timer after 1 second', function()\n\t\tlocal infiniteTimerGame = require(Workspace.infiniteTimerGame)\n\t\tlocal callback = jest.fn()\n\n\t\tinfiniteTimerGame(callback)\n\t\t-- At this point in time, there should have been a single call to\n\t\t-- setTimeout to schedule the end of the game in 1 second.\n\n\t\t-- Fast forward and exhaust only currently pending timers\n\t\t-- (but not any new timers that get created during that process)\n\t\tjest.runOnlyPendingTimers()\n\n\t\t-- At this point, our 1-second timer should have fired its callback\n\t\texpect(callback).toBeCalled()\n\n\t\t-- And it should have created a new timer to start the game over in\n\t\t-- 10 seconds\n\tend)\nend)\n"})}),"\n",(0,a.jsx)(t.h2,{id:"advance-timers-by-time",children:"Advance Timers by Time"}),"\n",(0,a.jsx)("img",{alt:"deviation",src:"img/deviation.svg"}),"\n",(0,a.jsxs)(t.p,{children:["Another possibility is use ",(0,a.jsx)(t.code,{children:"jest.advanceTimersByTime(secsToRun)"}),". When this API is called, all timers are advanced by ",(0,a.jsx)(t.code,{children:"secsToRun"}),' seconds. All pending "macro-tasks" that have been queued, and would be executed during this time frame, will be executed. Additionally, if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue that should be run within ',(0,a.jsx)(t.code,{children:"secsToRun"})," seconds."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",metastring:'title="timerGame.lua"',children:"return function(callback)\n\tprint('Ready....go!')\n\ttask.delay(1, function()\n\t\tprint(\"Time's up -- stop!\")\n\t\tif callback do\n\t\t\tcallback()\n\t\tend\n\tend)\nend\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",metastring:'title="__tests__/timerGame-test.spec.lua"',children:"jest.useFakeTimers()\n\ntest('calls the callback after 1 second via advanceTimersByTime', function()\n\tlocal timerGame = require(Workspace.timerGame)\n\tlocal callback = jest.fn()\n\n\ttimerGame(callback)\n\n\t-- At this point in time, the callback should not have been called yet\n\texpect(callback).never.toBeCalled()\n\n\t-- Fast-forward until all timers have been executed\n\tjest.advanceTimersByTime(1)\n\n\t-- Now our callback should have been called!\n\texpect(callback).toBeCalled()\n\texpect(callback).toHaveBeenCalledTimes(1)\nend)\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Lastly, it may occasionally be useful in some tests to be able to clear all of the pending timers. For this, we have ",(0,a.jsx)(t.code,{children:"jest.clearAllTimers()"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"setting-engine-frame-time",children:"Setting Engine Frame Time"}),"\n",(0,a.jsx)("img",{alt:"Roblox only",src:"img/roblox-only.svg"}),"\n",(0,a.jsx)(t.p,{children:"By default, Jest Lua processes fake timers in continuous time. However, because the Roblox engine processes timers only once per frame, this may not accurately reflect engine behavior."}),"\n",(0,a.jsxs)(t.p,{children:["To more closely mock engine behavior, Jest Lua allows you to configure an engine frame time, which ensures that timers are queued and run more similarly to how the engine ",(0,a.jsx)(t.a,{href:"https://create.roblox.com/docs/optimization/microprofiler/task-scheduler",children:"task scheduler"})," queues and runs timers. ",(0,a.jsx)(t.code,{children:"jest.advanceTimersByTime()"})," will behave like an equivalent ",(0,a.jsx)(t.code,{children:"task.wait()"}),", particularly at micro time-scales."]}),"\n",(0,a.jsxs)(t.p,{children:["Roblox currently runs at a 60 frames a second, which can be configured with ",(0,a.jsx)(t.code,{children:"jest.setEngineFrameTime(1000/60)"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",metastring:'title="timerGame.lua"',children:"return function(callback)\n\tprint('Ready....go!')\n\ttask.delay(0.01, function()\n\t\tprint(\"Time's up -- stop!\")\n\t\tif callback do\n\t\t\tcallback()\n\t\tend\n\tend)\nend\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",metastring:'title="__tests__/timerGame-test.spec.lua"',children:"jest.useFakeTimers()\n\ntest('calls the callback after advanceTimersByTime advances by 1 frame', function()\n\tlocal timerGame = require(Workspace.timerGame)\n\tlocal callback = jest.fn()\n\n\t-- frameTime is set in milliseconds\n\tjest.setEngineFrameTime(1000/60)\n\n\ttimerGame(callback)\n\n\t-- At this point in time, the callback should not have been called yet\n\texpect(callback).never.toBeCalled()\n\n\t-- Timer is advanced by about 16ms, since a 0 second timer is processed in the next frame\n\tjest.advanceTimersByTime(0)\n\n\t-- Now our callback should have been called!\n\texpect(callback).toBeCalled()\n\texpect(callback).toHaveBeenCalledTimes(1)\nend)\n"})})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>c});var a=n(6540);const i={},s=a.createContext(i);function l(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);