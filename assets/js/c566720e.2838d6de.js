"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[921],{4261:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>x,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var s=n(4848),a=n(8453),r=n(4252);const i={id:"expect",title:"Expect"},o=void 0,c={id:"expect",title:"Expect",description:'When you\'re writing tests, you often need to check that values meet certain conditions. expect gives you access to a number of "matchers" that let you validate different things.',source:"@site/docs/ExpectAPI.md",sourceDirName:".",slug:"/expect",permalink:"/jest-lua/expect",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"expect",title:"Expect"},sidebar:"api",previous:{title:"Globals",permalink:"/jest-lua/api"},next:{title:"Mock Functions",permalink:"/jest-lua/mock-function-api"}},l={},d=[{value:"RegExp",id:"regexp",level:3},{value:"Promise",id:"promise",level:3},{value:"Error",id:"error",level:3},{value:"Methods",id:"methods",level:2},{value:"Reference",id:"reference",level:2},{value:"<code>expect(value)</code>",id:"expectvalue",level:3},{value:"<code>expect.extend(matchers)</code>",id:"expectextendmatchers",level:3},{value:"Custom Matchers API",id:"custom-matchers-api",level:4},{value:"<code>self.isNever</code>",id:"selfisnever",level:4},{value:"<code>self.equals(a, b)</code>",id:"selfequalsa-b",level:4},{value:"<code>self.utils</code>",id:"selfutils",level:4},{value:"Custom snapshot matchers",id:"custom-snapshot-matchers",level:4},{value:"<code>expect.anything()</code>",id:"expectanything",level:3},{value:"<code>expect.any(typename | prototype)</code>",id:"expectanytypename--prototype",level:3},{value:"<code>expect.nothing()</code>",id:"expectnothing",level:3},{value:"<code>expect.arrayContaining(array)</code>",id:"expectarraycontainingarray",level:3},{value:"<code>expect.assertions(number)</code>",id:"expectassertionsnumber",level:3},{value:"<code>expect.hasAssertions()</code>",id:"expecthasassertions",level:3},{value:"<code>expect.never.arrayContaining(array)</code>",id:"expectneverarraycontainingarray",level:3},{value:"<code>expect.never.objectContaining(table)</code>",id:"expectneverobjectcontainingtable",level:3},{value:"<code>expect.never.stringContaining(string)</code>",id:"expectneverstringcontainingstring",level:3},{value:"<code>expect.never.stringMatching(string | regexp)</code>",id:"expectneverstringmatchingstring--regexp",level:3},{value:"<code>expect.objectContaining(table)</code>",id:"expectobjectcontainingtable",level:3},{value:"<code>expect.stringContaining(string)</code>",id:"expectstringcontainingstring",level:3},{value:"<code>expect.stringMatching(string | regexp)</code>",id:"expectstringmatchingstring--regexp",level:3},{value:"<code>expect.addSnapshotSerializer(serializer)</code>",id:"expectaddsnapshotserializerserializer",level:3},{value:"<code>.never</code>",id:"never",level:3},{value:"<code>.resolves</code>",id:"resolves",level:3},{value:"<code>.rejects</code>",id:"rejects",level:3},{value:"<code>.toBe(value)</code>",id:"tobevalue",level:3},{value:"<code>.toHaveBeenCalled()</code>",id:"tohavebeencalled",level:3},{value:"<code>.toHaveBeenCalledTimes(number)</code>",id:"tohavebeencalledtimesnumber",level:3},{value:"<code>.toHaveBeenCalledWith(arg1, arg2, ...)</code>",id:"tohavebeencalledwitharg1-arg2-",level:3},{value:"<code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code>",id:"tohavebeenlastcalledwitharg1-arg2-",level:3},{value:"<code>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)</code>",id:"tohavebeennthcalledwithnthcall-arg1-arg2-",level:3},{value:"<code>.toHaveReturned()</code>",id:"tohavereturned",level:3},{value:"<code>.toHaveReturnedTimes(number)</code>",id:"tohavereturnedtimesnumber",level:3},{value:"<code>.toHaveReturnedWith(value)</code>",id:"tohavereturnedwithvalue",level:3},{value:"<code>.toHaveLastReturnedWith(value)</code>",id:"tohavelastreturnedwithvalue",level:3},{value:"<code>.toHaveNthReturnedWith(nthCall, value)</code>",id:"tohaventhreturnedwithnthcall-value",level:3},{value:"<code>.toHaveLength(number)</code>",id:"tohavelengthnumber",level:3},{value:"<code>.toHaveProperty(keyPath, value?)</code>",id:"tohavepropertykeypath-value",level:3},{value:"<code>.toBeCloseTo(number, numDigits?)</code>",id:"tobeclosetonumber-numdigits",level:3},{value:"<code>.toBeDefined()</code>",id:"tobedefined",level:3},{value:"<code>.toBeFalsy()</code>",id:"tobefalsy",level:3},{value:"<code>.toBeGreaterThan(number)</code>",id:"tobegreaterthannumber",level:3},{value:"<code>.toBeGreaterThanOrEqual(number)</code>",id:"tobegreaterthanorequalnumber",level:3},{value:"<code>.toBeLessThan(number)</code>",id:"tobelessthannumber",level:3},{value:"<code>.toBeLessThanOrEqual(number)</code>",id:"tobelessthanorequalnumber",level:3},{value:"<code>.toBeInstanceOf(prototype)</code>",id:"tobeinstanceofprototype",level:3},{value:"<code>.toBeNil()</code>",id:"tobenil",level:3},{value:"<code>.toBeTruthy()</code>",id:"tobetruthy",level:3},{value:"<code>.toBeUndefined()</code>",id:"tobeundefined",level:3},{value:"<code>.toBeNan()</code>",id:"tobenan",level:3},{value:"<code>.toContain(item)</code>",id:"tocontainitem",level:3},{value:"<code>.toContainEqual(item)</code>",id:"tocontainequalitem",level:3},{value:"<code>.toEqual(value)</code>",id:"toequalvalue",level:3},{value:"<code>.toMatch(string | regexp)</code>",id:"tomatchstring--regexp",level:3},{value:"<code>.toMatchInstance(table)</code>",id:"tomatchinstancetable",level:3},{value:"<code>.toMatchObject(table)</code>",id:"tomatchobjecttable",level:3},{value:"<code>.toMatchSnapshot(propertyMatchers?, hint?)</code>",id:"tomatchsnapshotpropertymatchers-hint",level:3},{value:"<code>.toStrictEqual(value)</code>",id:"tostrictequalvalue",level:3},{value:"<code>.toThrow(error?)</code>",id:"tothrowerror",level:3},{value:"<code>.toThrowErrorMatchingSnapshot(hint?)</code>",id:"tothrowerrormatchingsnapshothint",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("p",{children:(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})})}),"\n",(0,s.jsxs)(t.p,{children:["When you're writing tests, you often need to check that values meet certain conditions. ",(0,s.jsx)(t.code,{children:"expect"}),' gives you access to a number of "matchers" that let you validate different things.']}),"\n",(0,s.jsx)("img",{alt:"deviation",src:"img/deviation.svg"}),"\n",(0,s.jsxs)(t.p,{children:["It must be imported explicitly from ",(0,s.jsx)(t.code,{children:"JestGlobals"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'local expect = require("@DevPackages/JestGlobals").expect\n'})}),"\n",(0,s.jsx)(t.h3,{id:"regexp",children:"RegExp"}),"\n",(0,s.jsx)("img",{alt:"Roblox only",src:"img/roblox-only.svg"}),"\n",(0,s.jsxs)(t.p,{children:["To use regular expressions in matchers that support it, you need to add ",(0,s.jsx)(t.a,{href:"https://github.com/Roblox/luau-regexp",children:"LuauRegExp"})," as a dependency in your ",(0,s.jsx)(t.code,{children:"rotriever.toml"})," and require it in your code."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",metastring:'title="rotriever.toml"',children:'RegExp = "github.com/roblox/luau-regexp@0.2.0"\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'local RegExp = require("@Packages/RegExp")\n'})}),"\n",(0,s.jsx)(t.h3,{id:"promise",children:"Promise"}),"\n",(0,s.jsx)("img",{alt:"Roblox only",src:"img/roblox-only.svg"}),"\n",(0,s.jsxs)(t.p,{children:["To use Promises in your tests, add ",(0,s.jsx)(t.a,{href:"https://github.com/Roblox/roblox-lua-promise",children:"roblox-lua-promise"})," as a dependency in your ",(0,s.jsx)(t.code,{children:"rotriever.toml"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'Promise = "github.com/evaera/roblox-lua-promise@3.3.0"\n'})}),"\n",(0,s.jsx)(t.h3,{id:"error",children:"Error"}),"\n",(0,s.jsx)("img",{alt:"Roblox only",src:"img/roblox-only.svg"}),"\n",(0,s.jsxs)(t.p,{children:["LuauPolyfill also provides an extensible ",(0,s.jsx)(t.code,{children:"Error"})," class that can be used with throwing matchers."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'local LuauPolyfill = require("@Packages/LuauPolyfill")\nlocal Error = LuauPolyfill.Error\n'})}),"\n",(0,s.jsxs)(t.p,{children:["To create a custom ",(0,s.jsx)(t.code,{children:"Error"}),", require ",(0,s.jsx)(t.code,{children:"extends"})," from LuauPolyfill and call it on the ",(0,s.jsx)(t.code,{children:"Error"})," class."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local extends = LuauPolyfill.extends\n\nlocal OhNoError = extends(Error, 'OhNoError', function(self, message)\n\tself.message = message\n\tself.name = 'OhNoError'\nend)\n\nlocal function thisFunctionErrors()\n\terror(OhNoError('oh no'))\nend\n"})}),"\n",(0,s.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n","\n","\n",(0,s.jsx)(r.A,{toc:d.slice(3).filter((e=>3===e.level))}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"reference",children:"Reference"}),"\n",(0,s.jsx)(t.h3,{id:"expectvalue",children:(0,s.jsx)(t.code,{children:"expect(value)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectvalue",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"expect"})," function is used every time you want to test a value. You will rarely call ",(0,s.jsx)(t.code,{children:"expect"})," by itself. Instead, you will use ",(0,s.jsx)(t.code,{children:"expect"}),' along with a "matcher" function to assert something about value.']}),"\n",(0,s.jsxs)(t.p,{children:["It's easier to understand this with an example. Let's say you have a method ",(0,s.jsx)(t.code,{children:"bestLaCroixFlavor()"})," which is supposed to return the string ",(0,s.jsx)(t.code,{children:"'grapefruit'"}),". Here's how you would test that:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('the best flavor is grapefruit', function()\n\texpect(bestLaCroixFlavor()).toBe('grapefruit')\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In this case, ",(0,s.jsx)(t.code,{children:"toBe"})," is the matcher function. There are a lot of different matcher functions, documented below, to help you test different things."]}),"\n",(0,s.jsxs)(t.p,{children:["The argument to ",(0,s.jsx)(t.code,{children:"expect"})," should be the value that your code produces, and any argument to the matcher should be the correct value. If you mix them up, your tests will still work, but the error messages on failing tests will look strange."]}),"\n",(0,s.jsx)(t.h3,{id:"expectextendmatchers",children:(0,s.jsx)(t.code,{children:"expect.extend(matchers)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectextendmatchers",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["You can use ",(0,s.jsx)(t.code,{children:"expect.extend"})," to add your own matchers to Jest Lua. For example, let's say that you're testing a number utility library and you're frequently asserting that numbers appear within particular ranges of other numbers. You could abstract that into a ",(0,s.jsx)(t.code,{children:"toBeWithinRange"})," matcher:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"expect.extend({\n\ttoBeWithinRange = function(self, received, floor, ceiling)\n\t\tlocal pass = received >= floor and received <= ceiling\n\t\tlocal message\n\t\tif pass then\n\t\t\tmessage = function()\n\t\t\t\treturn string.format(\n\t\t\t\t\t'expected %s not to be within range %s - %s',\n\t\t\t\t\ttostring(actual), tostring(floor), tostring(ceiling)\n\t\t\t\t)\n\t\t\tend\n\t\telse\n\t\t\tmessage = function()\n\t\t\t\treturn string.format(\n\t\t\t\t\t'expected %s to be within range %s - %s',\n\t\t\t\t\ttostring(actual), tostring(floor), tostring(ceiling)\n\t\t\t\t)\n\t\t\tend\n\t\tend\n\t\treturn {message = message, pass = pass}\n\tend\n})\n\nit('numeric ranges', function()\n\texpect(100).toBeWithinRange(90, 110)\n\texpect(101).never.toBeWithinRange(0, 100)\n\texpect({apples = 6, bananas = 3}).toEqual({\n\t\tapples = expect.toBeWithinRange(1, 10),\n\t\tbananas = expect.never.toBeWithinRange(11, 20),\n\t})\n)\nend)\n"})}),"\n",(0,s.jsx)(t.h4,{id:"custom-matchers-api",children:"Custom Matchers API"}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Matchers should return a table with two keys. ",(0,s.jsx)(t.code,{children:"pass"})," indicates whether there was a match or not, and ",(0,s.jsx)(t.code,{children:"message"})," provides a function with no arguments that return an error message in case of failure. Thus, when ",(0,s.jsx)(t.code,{children:"pass"})," is false, ",(0,s.jsx)(t.code,{children:"message"})," should return the error message for when ",(0,s.jsx)(t.code,{children:"expect(x).yourMatcher()"})," fails. And when ",(0,s.jsx)(t.code,{children:"pass"})," is true, ",(0,s.jsx)(t.code,{children:"message"})," should return the error message for when ",(0,s.jsx)(t.code,{children:"expect(x).never.yourMatcher()"})," fails."]}),"\n",(0,s.jsxs)(t.p,{children:["Matchers are called with the argument passed to ",(0,s.jsx)(t.code,{children:"expect(x)"})," followed by the arguments passed to ",(0,s.jsx)(t.code,{children:".yourMatcher(y, z)"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"expect.extend({\n\tyourMatcher = function(_, y, z)\n\t\treturn {\n\t\t\tpass = true,\n\t\t\tmessage = function() return '' end\n\t\t}\n\tend\n})\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Note that the first argument of a custom matcher always needs to be a ",(0,s.jsx)(t.code,{children:"self"})," but it can be a ",(0,s.jsx)(t.code,{children:"_"})," if the ",(0,s.jsx)(t.code,{children:"matcherContext"})," does not need to be referenced."]}),"\n",(0,s.jsxs)(t.p,{children:["These helper functions and properties can be found on ",(0,s.jsx)(t.code,{children:"self"})," inside a custom matcher:"]}),"\n",(0,s.jsx)(t.h4,{id:"selfisnever",children:(0,s.jsx)(t.code,{children:"self.isNever"})}),"\n",(0,s.jsxs)(t.p,{children:["A boolean to let you know this matcher was called with the negated ",(0,s.jsx)(t.code,{children:".never"})," modifier allowing you to display a clear and correct matcher hint."]}),"\n",(0,s.jsx)(t.h4,{id:"selfequalsa-b",children:(0,s.jsx)(t.code,{children:"self.equals(a, b)"})}),"\n",(0,s.jsxs)(t.p,{children:["This is a deep-equality function that will return ",(0,s.jsx)(t.code,{children:"true"})," if two objects have the same values (recursively)."]}),"\n",(0,s.jsx)(t.h4,{id:"selfutils",children:(0,s.jsx)(t.code,{children:"self.utils"})}),"\n",(0,s.jsxs)(t.p,{children:["There are a number of helpful tools exposed on ",(0,s.jsx)(t.code,{children:"self.utils"})," primarily consisting of the exports from ",(0,s.jsx)(t.a,{href:"https://github.com/Roblox/jest-roblox/blob/master/src/jest-matcher-utils/src/init.lua",children:(0,s.jsx)(t.code,{children:"jest-matcher-utils"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The most useful ones are ",(0,s.jsx)(t.code,{children:"matcherHint"}),", ",(0,s.jsx)(t.code,{children:"printExpected"})," and ",(0,s.jsx)(t.code,{children:"printReceived"})," to format the error messages nicely. For example, take a look at this implementation for the ",(0,s.jsx)(t.code,{children:"toBe"})," matcher:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"expect.extend({\n\ttoBe = function(self, received, expected)\n\t\tlocal options = {\n\t\t\tcomment = 'shallow equality',\n\t\t\tisNot = self.isNot,\n\t\t\tpromise = self.promise,\n\t\t}\n\n\t\tlocal pass = received == expected\n\t\tlocal message\n\t\tif pass then\n\t\t\tmessage = function()\n\t\t\t\treturn self.utils.matcherHint('toBe', nil, nil, options) ..\n\t\t\t\t\t'\\n\\n' ..\n\t\t\t\t\tstring.format('Expected: never %s\\n', self.utils.printExpected(expected)) ..\n\t\t\t\t\tstring.format('Received: %s', self.utils.printReceived(expected))\n\t\t\tend\n\t\telse\n\t\t\tmessage = function()\n\t\t\t\treturn self.utils.matcherHint('toBe', nil, nil, options) ..\n\t\t\t\t\t'\\n\\n' ..\n\t\t\t\t\tstring.format('Expected: %s\\n', self.utils.printExpected(expected)) ..\n\t\t\t\t\tstring.format('Received: %s', self.utils.printReceived(expected))\n\t\t\tend\n\t\tend\n\n\t\treturn {actual = received, pass = pass message = message}\n\tend\n})\n"})}),"\n",(0,s.jsx)(t.p,{children:"This will print something like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:'expect(received).toBe(expected)\n\nExpected: "banana"\nReceived: "apple"\n'})}),"\n",(0,s.jsx)(t.p,{children:"When an assertion fails, the error message should give as much signal as necessary to the user so they can resolve their issue quickly. You should craft a precise failure message to make sure users of your custom assertions have a good developer experience."}),"\n",(0,s.jsx)(t.h4,{id:"custom-snapshot-matchers",children:"Custom snapshot matchers"}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["To use snapshot testing inside of your custom matcher you can import ",(0,s.jsx)(t.code,{children:"JestSnapshot"})," and use it from within your matcher."]}),"\n",(0,s.jsxs)(t.p,{children:["Here's a snapshot matcher that trims a string to store for a given length, ",(0,s.jsx)(t.code,{children:".toMatchTrimmedSnapshot(length)"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local JestSnapshot = require(\"@DevPackages/JestSnapshot\")\nlocal toMatchSnapshot = JestRoblox.JestSnapshot.toMatchSnapshot\n\nexpect.extend({\n\ttoMatchTrimmedSnapshot = function(self, received, length)\n\t\treturn toMatchSnapshot(\n\t\t\tself,\n\t\t\tstring.sub(received, 1, length),\n\t\t\t'toMatchTrimmedSnapshot'\n\t\t)\n\tend\n})\n\nit('stores only 10 characters', function()\n\texpect('extra long string oh my gerd').toMatchTrimmedSnapshot(10)\nend)\n\n-- Stored snapshot will look like:\n-- exports[\"another package custom snapshot matcher: toMatchTrimmedSnapshot 1\"] = [=[\n-- \"extra long\"]=]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"expectanything",children:(0,s.jsx)(t.code,{children:"expect.anything()"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectanything",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.anything()"})," matches anything but ",(0,s.jsx)(t.code,{children:"nil"}),". You can use it inside ",(0,s.jsx)(t.code,{children:"toEqual"})," or ",(0,s.jsx)(t.code,{children:"toBeCalledWith"})," instead of a literal value. For example, if you want to check that a mock function is called with a non-nil argument:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('mock calls its argument with a non-nil argument', function()\n\tlocal mock = jest.fn()\n\tmock('a')\n\texpect(mock).toBeCalledWith(expect.anything())\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"expectanytypename--prototype",children:(0,s.jsx)(t.code,{children:"expect.any(typename | prototype)"})}),"\n",(0,s.jsx)("a",{href:"http://localhost:3000/expect#expectanytypename--prototype",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"deviation",src:"img/deviation.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.any(typename)"})," matches anything that has the given type. ",(0,s.jsx)(t.code,{children:"expect.any(prototype)"})," matches anything that is an instance (or a derived instance) of the given prototype class. You can use it inside ",(0,s.jsx)(t.code,{children:"toEqual"})," or ",(0,s.jsx)(t.code,{children:"toBeCalledWith"})," instead of a literal value. For example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local function identity(a)\n\treturn a\nend\n\nit('identity calls its callback with CustomClass', function()\n\tlocal mock = jest.fn()\n\tidentity(CustomClass.new())\n\texpect(mock).toBeCalledWith(expect.any(CustomClass))\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In addition to Lua prototype classes, it also supports Roblox types like ",(0,s.jsx)(t.a,{href:"https://developer.roblox.com/en-us/api-reference/datatype/DateTime",children:(0,s.jsx)(t.code,{children:"DateTime"})}),", Luau types like ",(0,s.jsx)(t.code,{children:"thread"}),", ",(0,s.jsx)(t.code,{children:"RegExp"})," from the LuauRegExp library, and LuauPolyfill types like ",(0,s.jsx)(t.code,{children:"Symbol"}),", ",(0,s.jsx)(t.code,{children:"Set"}),", ",(0,s.jsx)(t.code,{children:"Error"})," etc."]}),"\n",(0,s.jsx)(t.h3,{id:"expectnothing",children:(0,s.jsx)(t.code,{children:"expect.nothing()"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectnothing",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"deviation",src:"img/deviation.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.nothing()"})," matches only ",(0,s.jsx)(t.code,{children:"nil"}),". You can use it inside ",(0,s.jsx)(t.code,{children:"toEqual"}),", ",(0,s.jsx)(t.code,{children:"toMatchObject"}),", ",(0,s.jsx)(t.code,{children:"toBeCalledWith"}),", or similar matchers instead of a literal value. For example, if you want to check that a value is left undefined in a table:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'it(\'mock calls its argument with a nil argument\', function()\n\tlocal expected = {\n\t\tfoo = "bar",\n\t\tbaz = expect.nothing(),\n\t}\n\tmock()\n\texpect({ foo = "bar" }).toMatchObject({ expected })\nend)\n'})}),"\n",(0,s.jsx)(t.h3,{id:"expectarraycontainingarray",children:(0,s.jsx)(t.code,{children:"expect.arrayContaining(array)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectarraycontainingarray",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.arrayContaining(array)"})," matches a received array which contains all of the elements in the expected array. That is, the expected array is a ",(0,s.jsx)(t.strong,{children:"subset"})," of the received array. Therefore, it matches a received array which contains elements that are ",(0,s.jsx)(t.strong,{children:"not"})," in the expected array."]}),"\n",(0,s.jsx)(t.p,{children:"You can use it instead of a literal value:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["in ",(0,s.jsx)(t.code,{children:"toEqual"})]}),"\n",(0,s.jsxs)(t.li,{children:["to match a property in ",(0,s.jsx)(t.code,{children:"objectContaining"})," or ",(0,s.jsx)(t.code,{children:"toMatchObject"})]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"describe('arrayContaining', function()\n\tlocal expected = {'Alice', 'Bob'}\n\tit('matches even if received contains additional elements', function()\n\t\texpect({'Alice', 'Bob', 'Eve'}).toEqual(expect.arrayContaining(expected))\n\tend)\n\tit('does not match if received does not contain expected elements', function()\n\t\texpect({'Bob', 'Eve'}).never.toEqual(expect.arrayContaining(expected))\n\tend)\nend)\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"describe('Beware of a misunderstanding! A sequence of dice rolls', function()\n\tlocal expected = {1, 2, 3, 4, 5, 6}\n\tit('matches even with an unexpected number 7', function()\n\t\texpect({4, 1, 6, 7, 3, 5, 2, 5, 4, 6}).toEqual(\n\t\t\texpect.arrayContaining(expected)\n\t\t)\n\tend)\n\tit('does not match without an expected number 2', function()\n\t\texpect({4, 1, 6, 7, 3, 5, 7, 5, 4, 6}).never.toEqual(\n\t\t\texpect.arrayContaining(expected)\n\t\t)\n\tend)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"expectassertionsnumber",children:(0,s.jsx)(t.code,{children:"expect.assertions(number)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectassertionsnumber",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.assertions(number)"})," verifies that a certain number of assertions are called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say that we have a function ",(0,s.jsx)(t.code,{children:"doAsync"})," that receives two callbacks ",(0,s.jsx)(t.code,{children:"callback1"})," and ",(0,s.jsx)(t.code,{children:"callback2"}),", it will asynchronously call both of them in an unknown order. We can test this with:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"test('doAsync calls both callbacks', function()\n\texpect.assertions(2)\n\tlocal function callback1(data)\n\t\texpect(data).toBeTruthy()\n\tend\n\n\tlocal function callback2(data)\n\t\texpect(data).toBeTruthy()\n\tend\n\n\tdoAsync(callback1, callback2)\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"expect.assertions(2)"})," call ensures that both callbacks actually get called."]}),"\n",(0,s.jsx)(t.h3,{id:"expecthasassertions",children:(0,s.jsx)(t.code,{children:"expect.hasAssertions()"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expecthasassertions",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.hasAssertions()"})," verifies that at least one assertion is called during a test. This is often useful when testing asynchronous code, in order to make sure that assertions in a callback actually got called."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say that we have a few functions that all deal with state. ",(0,s.jsx)(t.code,{children:"prepareState"})," calls a callback with a state object, ",(0,s.jsx)(t.code,{children:"validateState"})," runs on that state object, and ",(0,s.jsx)(t.code,{children:"waitOnState"})," returns a promise that waits until all ",(0,s.jsx)(t.code,{children:"prepareState"})," callbacks complete. We can test this with:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"test('prepareState prepares a valid state', function()\n\texpect.hasAssertions()\n\tprepareState(function(state)\n\t\texpect(validateState(state)).toBeTruthy()\n\tend)\n\treturn waitOnState()\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"expect.hasAssertions()"})," call ensures that the ",(0,s.jsx)(t.code,{children:"prepareState"})," callback actually gets called."]}),"\n",(0,s.jsx)(t.h3,{id:"expectneverarraycontainingarray",children:(0,s.jsx)(t.code,{children:"expect.never.arrayContaining(array)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectnotarraycontainingarray",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.never.arrayContaining(array)"})," matches a received array which does not contain all of the elements in the expected array. That is, the expected array ",(0,s.jsx)(t.strong,{children:"is not a subset"})," of the received array."]}),"\n",(0,s.jsxs)(t.p,{children:["It is the inverse of ",(0,s.jsx)(t.code,{children:"expect.arrayContaining"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"describe('never.arrayContaining', function()\n\tlocal expected = {'Samantha'}\n\n\tit('matches if the actual array does not contain the expected elements', function()\n\t\texpect({'Alice', 'Bob', 'Eve'}).toEqual(\n\t\t\texpect.never.arrayContaining(expected),\n\t\t)\n\tend)\nend)\n"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".arrayNotContaining(array)"})]}),"\n",(0,s.jsx)(t.h3,{id:"expectneverobjectcontainingtable",children:(0,s.jsx)(t.code,{children:"expect.never.objectContaining(table)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectnotobjectcontainingobject",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.never.objectContaining(table)"})," matches any received table that does not recursively match the expected properties. That is, the expected table ",(0,s.jsx)(t.strong,{children:"is not a subset"})," of the received table. Therefore, it matches a received table which contains properties that are ",(0,s.jsx)(t.strong,{children:"not"})," in the expected table."]}),"\n",(0,s.jsxs)(t.p,{children:["It is the inverse of ",(0,s.jsx)(t.code,{children:"expect.objectContaining"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"describe('never.objectContaining', function()\n\tlocal expected = {foo = 'bar'}\n\n\tit('matches if the actual object does not contain expected key: value pairs', function()\n\t\texpect({bar = 'baz'}).toEqual(expect.never.objectContaining(expected))\n\tend)\nend)\n"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".objectNotContaining(table)"})]}),"\n",(0,s.jsx)(t.h3,{id:"expectneverstringcontainingstring",children:(0,s.jsx)(t.code,{children:"expect.never.stringContaining(string)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectnotstringcontainingstring",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.never.stringContaining(string)"})," matches the received value if it is not a string or if it is a string that does not contain the exact expected string."]}),"\n",(0,s.jsxs)(t.p,{children:["It is the inverse of ",(0,s.jsx)(t.code,{children:"expect.stringContaining"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"describe('never.stringContaining', function()\n\tlocal expected = 'Hello world!'\n\n\tit('matches if the received value does not contain the expected substring', function()\n\t\texpect('How are you?').toEqual(expect.never.stringContaining(expected))\n\tend)\nend)\n"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".stringNotContaining(string)"})]}),"\n",(0,s.jsx)(t.h3,{id:"expectneverstringmatchingstring--regexp",children:(0,s.jsx)(t.code,{children:"expect.never.stringMatching(string | regexp)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectnotstringmatchingstring--regexp",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.never.stringMatching(string | regexp)"})," matches the received value if it is not a string or if it is a string that does not match the expected ",(0,s.jsx)(t.a,{href:"https://developer.roblox.com/en-us/articles/string-patterns-reference",children:"Lua string pattern"})," or ",(0,s.jsx)(t.a,{href:"#regexp",children:"regular expression"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["It is the inverse of ",(0,s.jsx)(t.code,{children:"expect.stringMatching"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"describe('never.stringMatching', function()\n\tlocal expected = 'Hello world!'\n\n\tit('matches if the received value does not match the expected regex', function()\n\t\texpect('How are you?').toEqual(expect.never.stringMatching(expected))\n\tend)\nend)\n"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".stringNotMatching(string | regexp)"})]}),"\n",(0,s.jsx)(t.h3,{id:"expectobjectcontainingtable",children:(0,s.jsx)(t.code,{children:"expect.objectContaining(table)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectobjectcontainingobject",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.objectContaining(table)"})," matches any received table that recursively matches the expected properties. That is, the expected table is a ",(0,s.jsx)(t.strong,{children:"subset"})," of the received table. Therefore, it matches a received table which contains properties that ",(0,s.jsx)(t.strong,{children:"are present"})," in the expected table."]}),"\n",(0,s.jsxs)(t.p,{children:["Instead of literal property values in the expected table, you can use matchers, ",(0,s.jsx)(t.code,{children:"expect.anything()"}),", and so on."]}),"\n",(0,s.jsx)(t.p,{children:"For example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('received contains a number x and a number y', function()\n\tlocal received = {x = 10, y = 20, z = 30}\n\texpect(received).toEqual(\n\t\texpect.objectContaining({\n\t\t\tx = expect.any('number'),\n\t\t\ty = expect.any('number'),\n\t\t})\n\t)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"expectstringcontainingstring",children:(0,s.jsx)(t.code,{children:"expect.stringContaining(string)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectstringcontainingstring",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.stringContaining(string)"})," matches the received value if it is a string that contains the exact expected string."]}),"\n",(0,s.jsx)(t.h3,{id:"expectstringmatchingstring--regexp",children:(0,s.jsx)(t.code,{children:"expect.stringMatching(string | regexp)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectstringmatchingstring--regexp",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"expect.stringMatching(string | regexp)"})," matches the received value if it is a string that matches the expected ",(0,s.jsx)(t.a,{href:"https://developer.roblox.com/en-us/articles/string-patterns-reference",children:"Lua string pattern"})," or ",(0,s.jsx)(t.a,{href:"#regexp",children:"regular expression"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"You can use it instead of a literal value:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["in ",(0,s.jsx)(t.code,{children:"toEqual"})]}),"\n",(0,s.jsxs)(t.li,{children:["to match an element in ",(0,s.jsx)(t.code,{children:"arrayContaining"})]}),"\n",(0,s.jsxs)(t.li,{children:["to match a property in ",(0,s.jsx)(t.code,{children:"objectContaining"})," or ",(0,s.jsx)(t.code,{children:"toMatchObject"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["This example also shows how you can nest multiple asymmetric matchers, with ",(0,s.jsx)(t.code,{children:"expect.stringMatching"})," inside the ",(0,s.jsx)(t.code,{children:"expect.arrayContaining"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"describe('stringMatching in arrayContaining', function()\n\tlocal expected = {\n\t\texpect.stringMatching(RegExp('^Alic')),\n\t\texpect.stringMatching(RegExp('^[BR]ob'),\n\t}\n\tit('matches even if received contains additional elements', function()\n\t\texpect({'Alicia', 'Roberto', 'Evelina'}).toEqual(\n\t\t\texpect.arrayContaining(expected)\n\t\t)\n\tend)\n\tit('does not match if received does not contain expected elements', function()\n\t\texpect({'Roberto', 'Evelina'}).never.toEqual(\n\t\t\texpect.arrayContaining(expected)\n\t\t)\n\tend)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"expectaddsnapshotserializerserializer",children:(0,s.jsx)(t.code,{children:"expect.addSnapshotSerializer(serializer)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#expectaddsnapshotserializerserializer",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["You can call ",(0,s.jsx)(t.code,{children:"expect.addSnapshotSerializer"})," to add a module that formats application-specific data structures."]}),"\n",(0,s.jsxs)(t.p,{children:["For an individual test file, an added module precedes any modules from ",(0,s.jsx)(t.code,{children:"snapshotSerializers"})," configuration, which precede the default snapshot serializers. The last module added is the first module tested."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"expect.addSnapshotSerializer(serializer)\n\n-- affects expect(value).toMatchSnapshot() assertions in the test file\n"})}),"\n",(0,s.jsxs)(t.p,{children:["See ",(0,s.jsx)(t.a,{href:"configuration",children:"configuring Jest Lua"})," for more information."]}),"\n",(0,s.jsx)(t.h3,{id:"never",children:(0,s.jsx)(t.code,{children:".never"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#not",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["If you know how to test something, ",(0,s.jsx)(t.code,{children:".never"})," lets you test its opposite. For example, this code tests that the best La Croix flavor is not coconut:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('the best flavor is not coconut', function()\n\texpect(bestLaCroixFlavor()).never.toBe('coconut')\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"resolves",children:(0,s.jsx)(t.code,{children:".resolves"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#resolves",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:"resolves"})," to unwrap the value of a fulfilled ",(0,s.jsx)(t.a,{href:"#promise",children:"promise"})," so any other matcher can be chained. If the promise is rejected the assertion fails."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, this code tests that the promise resolves and that the resulting value is ",(0,s.jsx)(t.code,{children:"'lemon'"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"test('resolves to lemon', function()\n\t-- make sure to add a return statement\n\treturn expect(Promise.resolve('lemon')).resolves.toBe('lemon')\nend)\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["Since you are still testing promises, the test is still asynchronous. Hence, you will need to ",(0,s.jsx)(t.a,{href:"asynchronous#promises",children:"tell Jest Lua to wait"})," by returning the unwrapped assertion."]})}),"\n",(0,s.jsx)(t.h3,{id:"rejects",children:(0,s.jsx)(t.code,{children:".rejects"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#rejects",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".rejects"})," to unwrap the reason of a rejected ",(0,s.jsx)(t.a,{href:"#promise",children:"promise"})," so any other matcher can be chained. If the promise is fulfilled the assertion fails."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, this code tests that the promise rejects with reason ",(0,s.jsx)(t.code,{children:"'octopus'"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"test('rejects to octopus', function()\n\t-- make sure to add a return statement\n\treturn expect(Promise.reject(Error.new('octopus'))).rejects.toThrow('octopus')\nend)\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["Since you are still testing promises, the test is still asynchronous. Hence, you will need to ",(0,s.jsx)(t.a,{href:"asynchronous#promises",children:"tell Jest Lua to wait"})," by returning the unwrapped assertion."]})}),"\n",(0,s.jsx)(t.h3,{id:"tobevalue",children:(0,s.jsx)(t.code,{children:".toBe(value)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobevalue",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toBe"})," to compare primitive values or to check referential identity of tables. It calls ",(0,s.jsxs)(t.a,{href:"https://github.com/Roblox/luau-polyfill/blob/main/src/Object/is.lua",children:["Luau Polyfill's ",(0,s.jsx)(t.code,{children:"Object.is"})]})," to compare values, which mostly behaves like the ",(0,s.jsx)(t.code,{children:"=="})," operator."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, this code will validate some properties of the ",(0,s.jsx)(t.code,{children:"can"})," object:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local can = {\n\tname = 'pamplemousse',\n\tounces = 12,\n}\n\ndescribe('the can', function()\n\tit('has 12 ounces', function()\n\t\texpect(can.ounces).toBe(12)\n\tend)\n\n\tit('has a sophisticated name', function()\n\t\texpect(can.name).toBe('pamplemousse')\n\tend)\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Don't use ",(0,s.jsx)(t.code,{children:".toBe"})," with floating-point numbers. For example, due to rounding, in Lua, ",(0,s.jsx)(t.code,{children:"0.2 + 0.1"})," is not strictly equal to ",(0,s.jsx)(t.code,{children:"0.3"}),". If you have floating point numbers, try ",(0,s.jsx)(t.code,{children:".toBeCloseTo"})," instead."]}),"\n",(0,s.jsxs)(t.p,{children:["Although the ",(0,s.jsx)(t.code,{children:".toBe"})," matcher ",(0,s.jsx)(t.strong,{children:"checks"})," referential identity, it ",(0,s.jsx)(t.strong,{children:"reports"})," a deep comparison of values if the assertion fails. If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the ",(0,s.jsx)(t.code,{children:"expect"})," function. For example, to assert whether or not elements are the same instance:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["rewrite ",(0,s.jsx)(t.code,{children:"expect(received).toBe(expected)"})," as ",(0,s.jsx)(t.code,{children:"expect(received == expected).toBe(true)"})]}),"\n",(0,s.jsxs)(t.li,{children:["rewrite ",(0,s.jsx)(t.code,{children:"expect(received).never.toBe(expected)"})," as ",(0,s.jsx)(t.code,{children:"expect(received == expected).toBe(false)"})]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"tohavebeencalled",children:(0,s.jsx)(t.code,{children:".toHaveBeenCalled()"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohavebeencalled",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".toBeCalled()"})]}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toHaveBeenCalled"})," to ensure that a mock function got called."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say you have a ",(0,s.jsx)(t.code,{children:"drinkAllExceptOctopus(drink, flavour)"})," function that takes a ",(0,s.jsx)(t.code,{children:"drink"})," function and applies it to all available beverages. You might want to check that ",(0,s.jsx)(t.code,{children:"drink"})," gets called for ",(0,s.jsx)(t.code,{children:"'lemon'"}),", but not for ",(0,s.jsx)(t.code,{children:"'octopus'"}),", because ",(0,s.jsx)(t.code,{children:"'octopus'"})," flavour is really weird and why would anything be octopus-flavoured? You can do that with this test suite:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local function drinkAllExceptOctopus(callback, flavour)\n\tif flavour ~= 'octopus' then\n\t\tcallback(flavour)\n\tend\nend\n\ndescribe('drinkAllExceptOctopus', function()\n\tit('drinks something lemon-flavoured', function()\n\t\tlocal drink = jest.fn()\n\t\tdrinkAllExceptOctopus(drink, 'lemon')\n\t\texpect(drink).toHaveBeenCalled()\n\tend)\n\n\tit('does not drink something octopus-flavoured', function()\n\t\tlocal drink = jest.fn()\n\t\tdrinkAllExceptOctopus(drink, 'octopus')\n\t\texpect(drink).never.toHaveBeenCalled()\n\tend)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tohavebeencalledtimesnumber",children:(0,s.jsx)(t.code,{children:".toHaveBeenCalledTimes(number)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohavebeencalledtimesnumber",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".toBeCalledTimes(number)"})]}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toHaveBeenCalledTimes"})," to ensure that a mock function got called exact number of times."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say you have a ",(0,s.jsx)(t.code,{children:"drinkEach(drink, table)"})," function that takes a ",(0,s.jsx)(t.code,{children:"drink"})," function and applies it to array of passed beverages. You might want to check that drink function was called exact number of times. You can do that with this test suite:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('drinkEach drinks each drink', function()\n\tlocal drink = jest.fn()\n\tdrinkEach(drink, {'lemon', 'octopus'})\n\texpect(drink).toHaveBeenCalledTimes(2)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tohavebeencalledwitharg1-arg2-",children:(0,s.jsx)(t.code,{children:".toHaveBeenCalledWith(arg1, arg2, ...)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohavebeencalledwitharg1-arg2-",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".toBeCalledWith()"})]}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toHaveBeenCalledWith"})," to ensure that a mock function was called with specific arguments."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say that you can register a beverage with a ",(0,s.jsx)(t.code,{children:"register"})," function, and ",(0,s.jsx)(t.code,{children:"applyToAll(f)"})," should apply the function ",(0,s.jsx)(t.code,{children:"f"})," to all registered beverages. To make sure this works, you could write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('registration applies correctly to orange La Croix', function()\n\tlocal beverage = LaCroix.new('orange')\n\tregister(beverage)\n\tlocal f = jest.fn()\n\tapplyToAll(f)\n\texpect(f).toHaveBeenCalledWith(beverage)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tohavebeenlastcalledwitharg1-arg2-",children:(0,s.jsx)(t.code,{children:".toHaveBeenLastCalledWith(arg1, arg2, ...)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohavebeenlastcalledwitharg1-arg2-",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".lastCalledWith(arg1, arg2, ...)"})]}),"\n",(0,s.jsxs)(t.p,{children:["If you have a mock function, you can use ",(0,s.jsx)(t.code,{children:".toHaveBeenLastCalledWith"})," to test what arguments it was most recently called with. For example, let's say you have a ",(0,s.jsx)(t.code,{children:"applyToAllFlavors(f)"})," function that applies ",(0,s.jsx)(t.code,{children:"f"})," to a bunch of flavors, and you want to ensure that when you call it, the last flavor it operates on is ",(0,s.jsx)(t.code,{children:"'mango'"}),". You can write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('applying to all flavors does mango last', function()\n\tlocal drink = jest.fn()\n\tapplyToAllFlavors(drink)\n\texpect(drink).toHaveBeenLastCalledWith('mango')\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tohavebeennthcalledwithnthcall-arg1-arg2-",children:(0,s.jsx)(t.code,{children:".toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohavebeennthcalledwithnthcall-arg1-arg2-",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".nthCalledWith(nthCall, arg1, arg2, ...)"})]}),"\n",(0,s.jsxs)(t.p,{children:["If you have a mock function, you can use ",(0,s.jsx)(t.code,{children:".toHaveBeenNthCalledWith"})," to test what arguments it was nth called with. For example, let's say you have a ",(0,s.jsx)(t.code,{children:"drinkEach(drink, Array<flavor>)"})," function that applies ",(0,s.jsx)(t.code,{children:"f"})," to a bunch of flavors, and you want to ensure that when you call it, the first flavor it operates on is ",(0,s.jsx)(t.code,{children:"'lemon'"})," and the second one is ",(0,s.jsx)(t.code,{children:"'octopus'"}),". You can write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('drinkEach drinks each drink', function()\n\tlocal drink = jest.fn()\n\tdrinkEach(drink, {'lemon', 'octopus'})\n\texpect(drink).toHaveBeenNthCalledWith(1, 'lemon')\n\texpect(drink).toHaveBeenNthCalledWith(2, 'octopus')\nend)\n"})}),"\n",(0,s.jsx)(t.p,{children:"Note: the nth argument must be positive integer starting from 1."}),"\n",(0,s.jsx)(t.h3,{id:"tohavereturned",children:(0,s.jsx)(t.code,{children:".toHaveReturned()"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohavereturned",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".toReturn()"})]}),"\n",(0,s.jsxs)(t.p,{children:["If you have a mock function, you can use ",(0,s.jsx)(t.code,{children:".toHaveReturned"})," to test that the mock function successfully returned (i.e., did not throw an error) at least one time. For example, let's say you have a mock ",(0,s.jsx)(t.code,{children:"drink"})," that returns ",(0,s.jsx)(t.code,{children:"true"}),". You can write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('drinks returns', function()\n\tlocal drink = jest.fn(function() return true end)\n\n\tdrink()\n\n\texpect(drink).toHaveReturned()\nend\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tohavereturnedtimesnumber",children:(0,s.jsx)(t.code,{children:".toHaveReturnedTimes(number)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohavereturnedtimesnumber",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".toReturnTimes(number)"})]}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toHaveReturnedTimes"})," to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(t.code,{children:"drink"})," that returns ",(0,s.jsx)(t.code,{children:"true"}),". You can write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('drink returns twice', function()\n\tlocal drink = jest.fn(function() return true end)\n\n\tdrink()\n\tdrink()\n\n\texpect(drink).toHaveReturnedTimes(2)\nend\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tohavereturnedwithvalue",children:(0,s.jsx)(t.code,{children:".toHaveReturnedWith(value)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohavereturnedwithvalue",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".toReturnWith(value)"})]}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toHaveReturnedWith"})," to ensure that a mock function returned a specific value."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(t.code,{children:"drink"})," that returns the name of the beverage that was consumed. You can write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('drink returns La Croix', function()\n\tlocal beverage = {name = 'La Croix'}\n\tlocal drink = jest.fn(function(beverage) return beverage.name end)\n\n\tdrink(beverage)\n\n\texpect(drink).toHaveReturnedWith('La Croix')\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tohavelastreturnedwithvalue",children:(0,s.jsx)(t.code,{children:".toHaveLastReturnedWith(value)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohavelastreturnedwithvalue",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".lastReturnedWith(value)"})]}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toHaveLastReturnedWith"})," to test the specific value that a mock function last returned. If the last call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(t.code,{children:"drink"})," that returns the name of the beverage that was consumed. You can write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('drink returns La Croix (Orange) last', function()\n\tlocal beverage1 = {name = 'La Croix (Lemon)'}\n\tlocal beverage2 = {name = 'La Croix (Orange)'}\n\tlocal drink = jest.fn(function(beverage) return beverage.name end)\n\n\tdrink(beverage1)\n\tdrink(beverage2)\n\n\texpect(drink).toHaveLastReturnedWith('La Croix (Orange)')\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tohaventhreturnedwithnthcall-value",children:(0,s.jsx)(t.code,{children:".toHaveNthReturnedWith(nthCall, value)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohaventhreturnedwithnthcall-value",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".nthReturnedWith(nthCall, value)"})]}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toHaveNthReturnedWith"})," to test the specific value that a mock function returned for the nth call. If the nth call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say you have a mock ",(0,s.jsx)(t.code,{children:"drink"})," that returns the name of the beverage that was consumed. You can write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('drink returns expected nth calls', () => {\n\tlocal beverage1 = {name = 'La Croix (Lemon)'}\n\tlocal beverage2 = {name = 'La Croix (Orange)'}\n\tlocal drink = jest.fn(function(beverage) return beverage.name end)\n\n\tdrink(beverage1)\n\tdrink(beverage2)\n\n\texpect(drink).toHaveNthReturnedWith(1, 'La Croix (Lemon)')\n\texpect(drink).toHaveNthReturnedWith(2, 'La Croix (Orange)')\nend\n"})}),"\n",(0,s.jsx)(t.p,{children:"Note: the nth argument must be positive integer starting from 1."}),"\n",(0,s.jsx)(t.h3,{id:"tohavelengthnumber",children:(0,s.jsx)(t.code,{children:".toHaveLength(number)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohavelengthnumber",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Deviation",src:"img/deviation.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toHaveLength"})," to check that an (array-like) table or string has a certain length. It calls the ",(0,s.jsx)(t.code,{children:"#"})," operator and since ",(0,s.jsx)(t.code,{children:"#"})," is only well defined for non-sparse array-like tables and strings it will return 0 for tables with key-value pairs. It checks the ",(0,s.jsx)(t.code,{children:".length"})," property of the table instead if it has one."]}),"\n",(0,s.jsx)(t.p,{children:"This is especially useful for checking arrays or strings size."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"expect({1, 2, 3}).toHaveLength(3)\nexpect('abc').toHaveLength(3)\nexpect('').never.toHaveLength(5)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tohavepropertykeypath-value",children:(0,s.jsx)(t.code,{children:".toHaveProperty(keyPath, value?)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tohavepropertykeypath-value",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toHaveProperty"})," to check if property at provided reference ",(0,s.jsx)(t.code,{children:"keyPath"})," exists for an object. For checking deeply nested properties in an object you may use dot notation or an array containing the ",(0,s.jsx)(t.code,{children:"keyPath"})," for deep references."]}),"\n",(0,s.jsxs)(t.p,{children:["You can provide an optional ",(0,s.jsx)(t.code,{children:"value"})," argument to compare the received property value (recursively for all properties of tables, also known as deep equality, like the ",(0,s.jsx)(t.code,{children:"toEqual"})," matcher)."]}),"\n",(0,s.jsxs)(t.p,{children:["The following example contains a ",(0,s.jsx)(t.code,{children:"houseForSale"})," object with nested properties. We are using ",(0,s.jsx)(t.code,{children:"toHaveProperty"})," to check for the existence and values of various properties in the object."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"-- Object containing house features to be tested\nlocal houseForSale = {\n\tbath = true,\n\tbedrooms = 4,\n\tkitchen = {\n\t\tamenities = {'oven', 'stove', 'washer'},\n\t\tarea = 20,\n\t\twallColor = 'white',\n\t\t'nice.oven' = true,\n\t},\n\t'ceiling.height' = 2,\n}\n\nit('this house has my desired features', function()\n\t-- Example Referencing\n\texpect(houseForSale).toHaveProperty('bath')\n\texpect(houseForSale).toHaveProperty('bedrooms', 4)\n\n\texpect(houseForSale).never.toHaveProperty('pool')\n\n\t-- Deep referencing using dot notation\n\texpect(houseForSale).toHaveProperty('kitchen.area', 20)\n\texpect(houseForSale).toHaveProperty('kitchen.amenities', {\n\t\t'oven',\n\t\t'stove',\n\t\t'washer',\n\t})\n\n\texpect(houseForSale).never.toHaveProperty('kitchen.open')\n\n\t-- Deep referencing using an array containing the keyPath\n\texpect(houseForSale).toHaveProperty({'kitchen', 'area'}, 20)\n\texpect(houseForSale).toHaveProperty(\n\t\t{'kitchen', 'amenities'},\n\t\t{'oven', 'stove', 'washer'},\n\t)\n\texpect(houseForSale).toHaveProperty({'kitchen', 'amenities', 1}, 'oven')\n\texpect(houseForSale).toHaveProperty({'kitchen', 'nice.oven'})\n\texpect(houseForSale).never.toHaveProperty({'kitchen', 'open'})\n\n\t-- Referencing keys with dot in the key itself\n\texpect(houseForSale).toHaveProperty({'ceiling.height'}, 'tall')\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tobeclosetonumber-numdigits",children:(0,s.jsx)(t.code,{children:".toBeCloseTo(number, numDigits?)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobeclosetonumber-numdigits",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:"toBeCloseTo"})," to compare floating point numbers for approximate equality."]}),"\n",(0,s.jsxs)(t.p,{children:["The optional ",(0,s.jsx)(t.code,{children:"numDigits"})," argument limits the number of digits to check ",(0,s.jsx)(t.strong,{children:"after"})," the decimal point. For the default value ",(0,s.jsx)(t.code,{children:"2"}),", the test criterion is ",(0,s.jsx)(t.code,{children:"math.abs(expected - received) < 0.005"})," (that is, ",(0,s.jsx)(t.code,{children:"10 ** -2 / 2"}),")."]}),"\n",(0,s.jsx)(t.p,{children:"Intuitive equality comparisons often fail, because arithmetic on decimal (base 10) values often have rounding errors in limited precision binary (base 2) representation. For example, this test fails:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('adding works sanely with decimals', function()\n\texpect(0.2 + 0.1).toBe(0.3) -- Fails!\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["It fails because in Lua, ",(0,s.jsx)(t.code,{children:"0.2 + 0.1"})," is actually ",(0,s.jsx)(t.code,{children:"0.30000000000000004"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"For example, this test passes with a precision of 5 digits:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('adding works sanely with decimals', function()\n\texpect(0.2 + 0.1).toBeCloseTo(0.3, 5)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tobedefined",children:(0,s.jsx)(t.code,{children:".toBeDefined()"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobedefined",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Deviation",src:"img/deviation.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toBeDefined"})," to check that a variable is not ",(0,s.jsx)(t.code,{children:"nil"}),". For example, if you want to check that a function ",(0,s.jsx)(t.code,{children:"fetchNewFlavorIdea()"})," returns ",(0,s.jsx)(t.em,{children:"something"}),", you can write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('there is a new flavor idea', function()\n\texpect(fetchNewFlavorIdea()).toBeDefined()\nend)\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:".toBeDefined"})," is functionally identical to ",(0,s.jsx)(t.code,{children:".never.toBeNil()"})," and usage of the latter is preferred."]})}),"\n",(0,s.jsx)(t.h3,{id:"tobefalsy",children:(0,s.jsx)(t.code,{children:".toBeFalsy()"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobefalsy",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Deviation",src:"img/deviation.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toBeFalsy"})," when you don't care what a value is and you want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"drinkSomeLaCroix()\nif not getErrors() then\n\tdrinkMoreLaCroix()\nend\n"})}),"\n",(0,s.jsxs)(t.p,{children:["You may not care what ",(0,s.jsx)(t.code,{children:"getErrors"})," returns, specifically - it might return ",(0,s.jsx)(t.code,{children:"false"})," or ",(0,s.jsx)(t.code,{children:"nil"}),", and your code would still work. So if you want to test there are no errors after drinking some La Croix, you could write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('drinking La Croix does not lead to errors', function()\n\tdrinkSomeLaCroix()\n\texpect(getErrors()).toBeFalsy()\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In Lua, there are two falsy values: ",(0,s.jsx)(t.code,{children:"false"})," and ",(0,s.jsx)(t.code,{children:"nil"}),". Everything else is truthy."]}),"\n",(0,s.jsx)(t.h3,{id:"tobegreaterthannumber",children:(0,s.jsx)(t.code,{children:".toBeGreaterThan(number)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobegreaterthannumber--bigint",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:"toBeGreaterThan"})," to compare ",(0,s.jsx)(t.code,{children:"received > expected"})," for number values. For example, test that ",(0,s.jsx)(t.code,{children:"ouncesPerCan()"})," returns a value of more than 10 ounces:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('ounces per can is more than 10', function()\n\texpect(ouncesPerCan()).toBeGreaterThan(10)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tobegreaterthanorequalnumber",children:(0,s.jsx)(t.code,{children:".toBeGreaterThanOrEqual(number)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobegreaterthanorequalnumber--bigint",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:"toBeGreaterThanOrEqual"})," to compare ",(0,s.jsx)(t.code,{children:"received >= expected"})," for number values. For example, test that ",(0,s.jsx)(t.code,{children:"ouncesPerCan()"})," returns a value of at least 12 ounces:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('ounces per can is at least 12', function()\n\texpect(ouncesPerCan()).toBeGreaterThanOrEqual(12)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tobelessthannumber",children:(0,s.jsx)(t.code,{children:".toBeLessThan(number)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobelessthannumber--bigint",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:"toBeLessThan"})," to compare ",(0,s.jsx)(t.code,{children:"received < expected"})," for number values. For example, test that ",(0,s.jsx)(t.code,{children:"ouncesPerCan()"})," returns a value of less than 20 ounces:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('ounces per can is less than 20', function()\n\texpect(ouncesPerCan()).toBeLessThan(20)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tobelessthanorequalnumber",children:(0,s.jsx)(t.code,{children:".toBeLessThanOrEqual(number)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobelessthanorequalnumber--bigint",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:"toBeLessThanOrEqual"})," to compare ",(0,s.jsx)(t.code,{children:"received <= expected"})," for number values. For example, test that ",(0,s.jsx)(t.code,{children:"ouncesPerCan()"})," returns a value of at most 12 ounces:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('ounces per can is at most 12', function()\n\texpect(ouncesPerCan()).toBeLessThanOrEqual(12)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tobeinstanceofprototype",children:(0,s.jsx)(t.code,{children:".toBeInstanceOf(prototype)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobeinstanceofclass",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Deviation",src:"img/deviation.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toBeInstanceOf(prototype)"})," to check that a value is an instance (or a derived instance) of a prototype class. This matcher uses the ",(0,s.jsxs)(t.a,{href:"https://github.com/Roblox/luau-polyfill/blob/main/src/instanceof.lua",children:[(0,s.jsx)(t.code,{children:"instanceof"})," method in LuauPolyfill"]})," underneath."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["Setting the ",(0,s.jsx)(t.code,{children:"__tostring"})," metamethod will result in nicer error outputs."]})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local A = {}\nA.__index = A\nsetmetatable(A, {\n\t__tostring = function(self) return 'A' end\n})\nfunction A.new()\n\tlocal self = {}\n\tsetmetatable(self, A)\n\treturn self\nend\n\nlocal B = {}\nB.__index = B\nsetmetatable(B, {\n\t__tostring = function(self) return 'B' end\n})\nfunction B.new()\n\tlocal self = {}\n\tsetmetatable(self, B)\n\treturn self\nend\n\nlocal C = extends(B, 'C', function(self) end)\n\nexpect(A.new()).toBeInstanceOf(A)\nexpect(B.new()).never.toBeInstanceOf(A)\nexpect(C.new()).toBeInstanceOf(B)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tobenil",children:(0,s.jsx)(t.code,{children:".toBeNil()"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobenull",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".toBeNull()"})]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:".toBeNil()"})," is the same as ",(0,s.jsx)(t.code,{children:".toBe(nil)"})," but the error messages are a bit nicer. So use ",(0,s.jsx)(t.code,{children:".toBeNil()"})," when you want to check that something is ",(0,s.jsx)(t.code,{children:"nil"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local function bloop()\n\treturn nil\nend\n\nit('bloop returns nil', function()\n\texpect(bloop()).toBeNil()\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tobetruthy",children:(0,s.jsx)(t.code,{children:".toBeTruthy()"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobetruthy",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Deviation",src:"img/deviation.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toBeTruthy"})," when you don't care what a value is and you want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"drinkSomeLaCroix()\nif thirstInfo() then\n\tdrinkMoreLaCroix()\nend\n"})}),"\n",(0,s.jsxs)(t.p,{children:["You may not care what ",(0,s.jsx)(t.code,{children:"thirstInfo"})," returns, specifically - it might return ",(0,s.jsx)(t.code,{children:"true"})," or a complex object, and your code would still work. So if you want to test that ",(0,s.jsx)(t.code,{children:"thirstInfo"})," will be truthy after drinking some La Croix, you could write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('drinking La Croix leads to having thirst info', function()\n\tdrinkSomeLaCroix()\n\texpect(thirstInfo()).toBeTruthy()\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In Lua, there are two falsy values: ",(0,s.jsx)(t.code,{children:"false"})," and ",(0,s.jsx)(t.code,{children:"nil"}),". Everything else is truthy."]}),"\n",(0,s.jsx)(t.h3,{id:"tobeundefined",children:(0,s.jsx)(t.code,{children:".toBeUndefined()"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobeundefined",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Deviation",src:"img/deviation.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toBeUndefined()"})," to check that a variable is ",(0,s.jsx)(t.code,{children:"nil"}),"."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:".toBeUndefined"})," is functionally identical to ",(0,s.jsx)(t.code,{children:".toBeNil()"})," and usage of the latter is preferred."]})}),"\n",(0,s.jsx)(t.h3,{id:"tobenan",children:(0,s.jsx)(t.code,{children:".toBeNan()"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tobenan",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".toBeNaN()"})]}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toBeNan"})," when checking a value is ",(0,s.jsx)(t.code,{children:"nan"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('passes when value is nan', function()\n\texpect(0/0).toBeNan()\n\texpect(1).never.toBeNan()\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tocontainitem",children:(0,s.jsx)(t.code,{children:".toContain(item)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tocontainitem",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toContain"})," when you want to check that an item is in an array. For testing the items in the array, this uses ",(0,s.jsx)(t.code,{children:"table.find"}),", which does a strict equality check. ",(0,s.jsx)(t.code,{children:".toContain"})," can also check whether a string is a substring of another string. This uses ",(0,s.jsx)(t.code,{children:"string.find"})," with ",(0,s.jsx)(t.code,{children:"plain = true"})," so magic characters are ignored."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, if ",(0,s.jsx)(t.code,{children:"getAllFlavors()"})," returns an array of flavors and you want to be sure that ",(0,s.jsx)(t.code,{children:"lime"})," is in there, you can write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('the flavor list contains lime', function()\n\texpect(getAllFlavors()).toContain('lime')\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tocontainequalitem",children:(0,s.jsx)(t.code,{children:".toContainEqual(item)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tocontainequalitem",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toContainEqual"})," when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for table identity."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"describe('my beverage', function()\n\tit('is delicious and not sour', function()\n\t\tlocal myBeverage = {delicious = true, sour = false}\n\t\texpect(myBeverages()).toContainEqual(myBeverage)\n\tend)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"toequalvalue",children:(0,s.jsx)(t.code,{children:".toEqual(value)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#toequalvalue",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toEqual"}),' to compare recursively all properties of tables (also known as "deep" equality). It calls ',(0,s.jsxs)(t.a,{href:"https://github.com/Roblox/luau-polyfill/blob/main/src/Object/is.lua",children:["Luau Polyfill's ",(0,s.jsx)(t.code,{children:"Object.is"})]})," to compare primitive values, which mostly behaves like the ",(0,s.jsx)(t.code,{children:"=="})," operator."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, ",(0,s.jsx)(t.code,{children:".toEqual"})," and ",(0,s.jsx)(t.code,{children:".toBe"})," behave differently in this test suite, so all the tests pass:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local can1 = {\n\tflavor = 'grapefruit',\n\tounces = 12,\n}\nlocal can2 = {\n\tflavor = 'grapefruit',\n\tounces = 12,\n}\n\ndescribe('the La Croix cans on my desk', function()\n\tit('have all the same properties', function()\n\t\texpect(can1).toEqual(can2)\n\tend)\n\tit('are not the exact same can', function()\n\t\texpect(can1).never.toBe(can2)\n\tend)\nend)\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:".toEqual"})," won't perform a ",(0,s.jsx)(t.em,{children:"deep equality"})," check for two errors. Only the ",(0,s.jsx)(t.code,{children:"message"})," property of an Error is considered for equality. It is recommended to use the ",(0,s.jsx)(t.code,{children:".toThrow"})," matcher for testing against errors."]})}),"\n",(0,s.jsxs)(t.p,{children:["If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the ",(0,s.jsx)(t.code,{children:"expect"})," function. For example, use ",(0,s.jsx)(t.code,{children:"equals"})," method of ",(0,s.jsx)(t.code,{children:"Buffer"})," class to assert whether or not buffers contain the same content:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["rewrite ",(0,s.jsx)(t.code,{children:"expect(received).toEqual(expected)"})," as ",(0,s.jsx)(t.code,{children:"expect(received.equals(expected)).toBe(true)"})]}),"\n",(0,s.jsxs)(t.li,{children:["rewrite ",(0,s.jsx)(t.code,{children:"expect(received).never.toEqual(expected)"})," as ",(0,s.jsx)(t.code,{children:"expect(received.equals(expected)).toBe(false)"})]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"tomatchstring--regexp",children:(0,s.jsx)(t.code,{children:".toMatch(string | regexp)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tomatchregexp--string",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toMatch"})," to check that a string matches a ",(0,s.jsx)(t.a,{href:"https://developer.roblox.com/en-us/articles/string-patterns-reference",children:"Lua string pattern"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, you might not know what exactly ",(0,s.jsx)(t.code,{children:"essayOnTheBestFlavor()"})," returns, but you know it's a really long string, and the substring ",(0,s.jsx)(t.code,{children:"grapefruit"})," should be in there somewhere. You can test this with:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"describe('an essay on the best flavor', function()\n\tit('mentions grapefruit', function()\n\t\texpect(essayOnTheBestFlavor()).toMatch('grapefruit')\n\tend)\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This matcher also accepts a ",(0,s.jsx)(t.a,{href:"#regexp",children:"regular expression"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"describe('an essay on the best flavor', function()\n\tit('mentions grapefruit or orange', function()\n\t\texpect(essayOnTheBestFlavor()).toMatch(RegExp('grapefruit|orange'))\n\tend)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tomatchinstancetable",children:(0,s.jsx)(t.code,{children:".toMatchInstance(table)"})}),"\n",(0,s.jsx)("img",{alt:"Roblox only",src:"img/roblox-only.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toMatchObject"})," to check that a Roblox Instance and its children matches all the properties defined in an expected table."]}),"\n",(0,s.jsxs)(t.p,{children:["If a ",(0,s.jsx)(t.code,{children:"ClassName"})," property is not in the table, the expected table will match against any class. To check that the received Instance is of a specific type, pass in a ",(0,s.jsx)(t.code,{children:"ClassName"})," property."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'local exampleList = Instance.new("ScrollingFrame")\nexampleList.Name = "Example List"\nexampleList.Size = UDim2.new(0, 400, 0, 600)\nexampleList.Position = UDim2.new(0.5, 0, 0.5, 0)\nexampleList.AnchorPoint = Vector2.new(0.5, 0.5)\n\nlocal listLayout = Instance.new("UIListLayout")\nlistLayout.Parent = exampleList\nlistLayout.Name = "List Layout"\n\nit(\'the ScrollingFrame has expected values\', function()\n\texpect(scrollingFrame).toMatchInstance({\n\t\tName = "Example List",\n\t\tPosition = UDim2.new(0.5, 0, 0.5, 0),\n\t\t["List Layout"] = {\n\t\t\tClassName = "UIListLayout"\n\t\t}\n\t})\nend)\n'})}),"\n",(0,s.jsx)(t.h3,{id:"tomatchobjecttable",children:(0,s.jsx)(t.code,{children:".toMatchObject(table)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tomatchobjectobject",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toMatchObject"})," to check that a table matches a subset of the properties of an expected table. It will match received tables with properties that are ",(0,s.jsx)(t.strong,{children:"not"})," in the expected table."]}),"\n",(0,s.jsxs)(t.p,{children:["You can also pass an array of tables, in which case the method will return true only if each table in the received array matches (in the ",(0,s.jsx)(t.code,{children:"toMatchObject"})," sense described above) the corresponding object in the expected array. This is useful if you want to check that two arrays match in their number of elements, as opposed to ",(0,s.jsx)(t.code,{children:"arrayContaining"}),", which allows for extra elements in the received array."]}),"\n",(0,s.jsx)(t.p,{children:"You can match properties against values or against matchers."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local houseForSale = {\n\tbath = true,\n\tbedrooms = 4,\n\tkitchen = {\n\t\tamenities = {'oven', 'stove', 'washer'},\n\t\tarea = 20,\n\t\twallColor = 'white',\n\t},\n}\nlocal desiredHouse = {\n\tbath = true,\n\tkitchen = {\n\t\tamenities = {'oven', 'stove', 'washer'},\n\t\twallColor = expect.stringMatching(RegExp('white|yellow')),\n\t},\n}\n\nit('the house has my desired features', function()\n\texpect(houseForSale).toMatchObject(desiredHouse)\nend)\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"describe('toMatchObject applied to arrays', function()\n\tit('the number of elements must match exactly', function()\n\t\texpect({{foo: 'bar'}, {baz: 1}}).toMatchObject({{foo: 'bar'}, {baz: 1}})\n\tend)\n\n\tit('.toMatchObject is called for each elements, so extra object properties are okay', function()\n\t\texpect({{foo: 'bar'}, {baz: 1, extra: 'quux'}}).toMatchObject({\n\t\t\t{foo: 'bar'},\n\t\t\t{baz: 1},\n\t\t})\n\tend)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tomatchsnapshotpropertymatchers-hint",children:(0,s.jsx)(t.code,{children:".toMatchSnapshot(propertyMatchers?, hint?)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tomatchsnapshotpropertymatchers-hint",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["This ensures that a value matches the most recent snapshot. Check out ",(0,s.jsx)(t.a,{href:"snapshot-testing",children:"the Snapshot Testing guide"})," for more information."]}),"\n",(0,s.jsxs)(t.p,{children:["You can provide an optional ",(0,s.jsx)(t.code,{children:"propertyMatchers"})," table argument, which has asymmetric matchers as values of a subset of expected properties, ",(0,s.jsx)(t.strong,{children:"if"})," the received value will be a ",(0,s.jsx)(t.strong,{children:"table"}),". It is like ",(0,s.jsx)(t.code,{children:"toMatchObject"})," with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties."]}),"\n",(0,s.jsxs)(t.p,{children:["You can provide an optional ",(0,s.jsx)(t.code,{children:"hint"})," string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate ",(0,s.jsx)(t.strong,{children:"multiple"})," snapshots in a ",(0,s.jsx)(t.strong,{children:"single"})," ",(0,s.jsx)(t.code,{children:"it"})," or ",(0,s.jsx)(t.code,{children:"test"})," block. Jest sorts snapshots by name in the corresponding ",(0,s.jsx)(t.code,{children:".snap"})," file."]}),"\n",(0,s.jsx)(t.h3,{id:"tostrictequalvalue",children:(0,s.jsx)(t.code,{children:".toStrictEqual(value)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tostrictequalvalue",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Deviation",src:"img/deviation.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toStrictEqual"})," to test that objects have the same types."]}),"\n",(0,s.jsxs)(t.p,{children:["Difference from ",(0,s.jsx)(t.code,{children:".toEqual"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Lua tables that follow metatable inheritance patterns will also be checked for type equality"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local LaCroix = {}\nLaCroix.__index = LaCroix\nfunction LaCroix.new(flavor)\n\treturn setmetatable({\n\t\tflavor = flavor\n\t}, LaCroix)\nend\n\ndescribe('the La Croix cans on my desk', function()\n\tit('the La Croix cans on my desk are not semantically the same', function()\n\t\tjestExpect(LaCroix.new('lemon')).toEqual({flavor = 'lemon'})\n\t\tjestExpect(LaCroix.new('lemon')).never.toStrictEqual({flavor = 'lemon'})\n\tend)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tothrowerror",children:(0,s.jsx)(t.code,{children:".toThrow(error?)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tothrowerror",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Also under the alias: ",(0,s.jsx)(t.code,{children:".toThrowError(error?)"})]}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toThrow"})," to test that a function throws when it is called. For example, if we want to test that ",(0,s.jsx)(t.code,{children:"drinkFlavor('octopus')"})," throws, because octopus flavor is too disgusting to drink, we could write:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('throws on octopus', function()\n\texpect(function()\n\t\tdrinkFlavor('octopus')\n\tend).toThrow()\nend)\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail."})}),"\n",(0,s.jsx)(t.p,{children:"You can provide an optional argument to test that a specific error is thrown:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"#regexp",children:"regular expression"}),": error message ",(0,s.jsx)(t.strong,{children:"matches"})," the pattern"]}),"\n",(0,s.jsxs)(t.li,{children:["string: error message ",(0,s.jsx)(t.strong,{children:"includes"})," the substring"]}),"\n"]}),"\n",(0,s.jsx)("img",{alt:"API change",src:"img/apichange.svg"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:".toThrow"})," can also handle custom Error objects provided by LuauPolyfill:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"#error",children:"error object"}),": error message is ",(0,s.jsx)(t.strong,{children:"equal to"})," the message property of the object"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"#error",children:"error class"}),": error object is ",(0,s.jsx)(t.strong,{children:"instance of"})," class"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say that ",(0,s.jsx)(t.code,{children:"drinkFlavor"})," is coded like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local Error = LuauPolyfill.Error\nlocal extends = LuauPolyfill.extends\n\nlocal DisgustingFlavorError = extends(Error, 'DisgustingFlavorError', function(self, message)\n\tself.message = message\n\tself.name = 'DisgustingFlavorError'\nend)\n\nlocal function drinkFlavor(flavor)\n\tif flavor == 'octopus' then\n\t\terror(DisgustingFlavorError('yuck, octopus flavor'))\n\tend\n\t-- Do some other stuff\nend\n"})}),"\n",(0,s.jsx)(t.p,{children:"We could test this error gets thrown in several ways:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('throws on octopus', function()\n\tlocal function drinkOctopus()\n\t\tdrinkFlavor('octopus')\n\tend\n\n\t-- Test that the error message says \"yuck\" somewhere: these are equivalent\n\texpect(drinkOctopus).toThrowError(RegExp('yuck'))\n\texpect(drinkOctopus).toThrowError('yuck')\n\n\t-- Test the exact error message\n\texpect(drinkOctopus).toThrowError(RegExp('^yuck, octopus flavor$'))\n\texpect(drinkOctopus).toThrowError(Error('yuck, octopus flavor'))\n\n\t-- Test that we get a DisgustingFlavorError\n\texpect(drinkOctopus).toThrowError(DisgustingFlavorError)\nend)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"tothrowerrormatchingsnapshothint",children:(0,s.jsx)(t.code,{children:".toThrowErrorMatchingSnapshot(hint?)"})}),"\n",(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/expect#tothrowerrormatchingsnapshothint",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})}),"\n",(0,s.jsx)("img",{alt:"Aligned",src:"img/aligned.svg"}),"\n",(0,s.jsxs)(t.p,{children:["Use ",(0,s.jsx)(t.code,{children:".toThrowErrorMatchingSnapshot"})," to test that a function throws an error matching the most recent snapshot when it is called."]}),"\n",(0,s.jsxs)(t.p,{children:["You can provide an optional ",(0,s.jsx)(t.code,{children:"hint"})," string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate ",(0,s.jsx)(t.strong,{children:"multiple"})," snapshots in a ",(0,s.jsx)(t.strong,{children:"single"})," ",(0,s.jsx)(t.code,{children:"it"})," or ",(0,s.jsx)(t.code,{children:"test"})," block. Jest sorts snapshots by name in the corresponding ",(0,s.jsx)(t.code,{children:".snap"})," file."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["You can throw and match against a native Lua string error, but it is recommended to pass in an ",(0,s.jsx)(t.a,{href:"expect#error",children:"error object"})," for cleaner snapshots."]})}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say you have a ",(0,s.jsx)(t.code,{children:"drinkFlavor"})," function that throws whenever the flavor is ",(0,s.jsx)(t.code,{children:"'octopus'"}),", and is coded like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local function drinkFlavor(flavor)\n\tif flavor == 'octopus' then\n\t\terror(Error('yuck, octopus flavor'))\n\tend\n\t-- Do some other stuff\nend\n"})}),"\n",(0,s.jsx)(t.p,{children:"The test for this function will look this way:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"it('throws on octopus', function()\n\tlocal function drinkOctopus()\n\t\tdrinkFlavor('octopus')\n\tend\n\n\texpect(drinkOctopus).toThrowErrorMatchingSnapshot()\nend)\n"})}),"\n",(0,s.jsx)(t.p,{children:"And it will generate the following snapshot:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'exports["drinking flavors throws on octopus 1"] = [=[\nyuck, octopus flavor]=]\n'})})]})}function x(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},4252:(e,t,n)=>{n.d(t,{A:()=>i});n(6540);var s=n(5195);const a={tableOfContentsInline:"tableOfContentsInline_prmo"};var r=n(4848);function i(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:i}=e;return(0,r.jsx)("div",{className:a.tableOfContentsInline,children:(0,r.jsx)(s.A,{toc:t,minHeadingLevel:n,maxHeadingLevel:i,className:"table-of-contents",linkClassName:null})})}},5195:(e,t,n)=>{n.d(t,{A:()=>g});var s=n(6540),a=n(6342);function r(e){const t=e.map((e=>({...e,parentIndex:-1,children:[]}))),n=Array(7).fill(-1);t.forEach(((e,t)=>{const s=n.slice(2,e.level);e.parentIndex=Math.max(...s),n[e.level]=t}));const s=[];return t.forEach((e=>{const{parentIndex:n,...a}=e;n>=0?t[n].children.push(a):s.push(a)})),s}function i(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:s}=e;return t.flatMap((e=>{const t=i({toc:e.children,minHeadingLevel:n,maxHeadingLevel:s});return function(e){return e.level>=n&&e.level<=s}(e)?[{...e,children:t}]:t}))}function o(e){const t=e.getBoundingClientRect();return t.top===t.bottom?o(e.parentNode):t}function c(e,t){let{anchorTopOffset:n}=t;const s=e.find((e=>o(e).top>=n));if(s){return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(o(s))?s:e[e.indexOf(s)-1]??null}return e[e.length-1]??null}function l(){const e=(0,s.useRef)(0),{navbar:{hideOnScroll:t}}=(0,a.p)();return(0,s.useEffect)((()=>{e.current=t?0:document.querySelector(".navbar").clientHeight}),[t]),e}function d(e){const t=(0,s.useRef)(void 0),n=l();(0,s.useEffect)((()=>{if(!e)return()=>{};const{linkClassName:s,linkActiveClassName:a,minHeadingLevel:r,maxHeadingLevel:i}=e;function o(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(s),o=function(e){let{minHeadingLevel:t,maxHeadingLevel:n}=e;const s=[];for(let a=t;a<=n;a+=1)s.push(`h${a}.anchor`);return Array.from(document.querySelectorAll(s.join()))}({minHeadingLevel:r,maxHeadingLevel:i}),l=c(o,{anchorTopOffset:n.current}),d=e.find((e=>l&&l.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e)));e.forEach((e=>{!function(e,n){n?(t.current&&t.current!==e&&t.current.classList.remove(a),e.classList.add(a),t.current=e):e.classList.remove(a)}(e,e===d)}))}return document.addEventListener("scroll",o),document.addEventListener("resize",o),o(),()=>{document.removeEventListener("scroll",o),document.removeEventListener("resize",o)}}),[e,n])}var h=n(8774),x=n(4848);function u(e){let{toc:t,className:n,linkClassName:s,isChild:a}=e;return t.length?(0,x.jsx)("ul",{className:a?void 0:n,children:t.map((e=>(0,x.jsxs)("li",{children:[(0,x.jsx)(h.A,{to:`#${e.id}`,className:s??void 0,dangerouslySetInnerHTML:{__html:e.value}}),(0,x.jsx)(u,{isChild:!0,toc:e.children,className:n,linkClassName:s})]},e.id)))}):null}const p=s.memo(u);function g(e){let{toc:t,className:n="table-of-contents table-of-contents__left-border",linkClassName:o="table-of-contents__link",linkActiveClassName:c,minHeadingLevel:l,maxHeadingLevel:h,...u}=e;const g=(0,a.p)(),j=l??g.tableOfContents.minHeadingLevel,m=h??g.tableOfContents.maxHeadingLevel,v=function(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:a}=e;return(0,s.useMemo)((()=>i({toc:r(t),minHeadingLevel:n,maxHeadingLevel:a})),[t,n,a])}({toc:t,minHeadingLevel:j,maxHeadingLevel:m});return d((0,s.useMemo)((()=>{if(o&&c)return{linkClassName:o,linkActiveClassName:c,minHeadingLevel:j,maxHeadingLevel:m}}),[o,c,j,m])),(0,x.jsx)(p,{toc:v,className:n,linkClassName:o,...u})}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var s=n(6540);const a={},r=s.createContext(a);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);