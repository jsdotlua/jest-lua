"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[807],{4377:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var s=n(4848),o=n(8453);const a={id:"asynchronous",title:"Testing Asynchronous Code"},r=void 0,c={id:"asynchronous",title:"Testing Asynchronous Code",description:"It's common in Lua for code to run asynchronously. When you have code that runs asynchronously, Jest Lua needs to know when the code it is testing has completed, before it can move on to another test. Jest Lua has several ways to handle this.",source:"@site/docs/TestingAsyncCode.md",sourceDirName:".",slug:"/asynchronous",permalink:"/jest-lua/asynchronous",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"asynchronous",title:"Testing Asynchronous Code"},sidebar:"docs",previous:{title:"Using Matchers",permalink:"/jest-lua/using-matchers"},next:{title:"Setup and Teardown",permalink:"/jest-lua/setup-teardown"}},i={},l=[{value:"Promises",id:"promises",level:2},{value:"Callbacks",id:"callbacks",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("p",{children:(0,s.jsx)("a",{href:"https://jestjs.io/docs/27.x/asynchronous",target:"_blank",children:(0,s.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})})}),"\n",(0,s.jsx)(t.p,{children:"It's common in Lua for code to run asynchronously. When you have code that runs asynchronously, Jest Lua needs to know when the code it is testing has completed, before it can move on to another test. Jest Lua has several ways to handle this."}),"\n",(0,s.jsx)(t.h2,{id:"promises",children:"Promises"}),"\n",(0,s.jsxs)(t.p,{children:["Return a ",(0,s.jsx)(t.a,{href:"https://github.com/evaera/roblox-lua-promise",children:"promise"})," from your test, and Jest Lua will wait for that promise to resolve. If the promise is rejected, the test will fail."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, let's say that ",(0,s.jsx)(t.code,{children:"fetchData"})," returns a promise that is supposed to resolve to the string ",(0,s.jsx)(t.code,{children:"'peanut butter'"}),". We could test it with:"]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["Tests can ",(0,s.jsx)(t.strong,{children:"ONLY"})," return either a ",(0,s.jsx)(t.code,{children:"Promise"})," or ",(0,s.jsx)(t.code,{children:"nil"}),"."]})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"test('the data is peanut butter', function()\n\treturn Promise.resolve()\n\t\t:andThen(function()\n\t\t\tlocal data = fetchData()\n\t\t\texpect(data).toBe('peanut butter')\n\t\tend)\nend)\n"})}),"\n",(0,s.jsx)(t.h2,{id:"callbacks",children:"Callbacks"}),"\n",(0,s.jsxs)(t.p,{children:["If you don't use promises, you can use callbacks. For example, let's say that ",(0,s.jsx)(t.code,{children:"fetchData"}),", instead of returning a promise, expects a callback, i.e. fetches some data and calls ",(0,s.jsx)(t.code,{children:"callback(error, data)"})," when it is complete. You want to test that this returned data is the string ",(0,s.jsx)(t.code,{children:"'peanut butter'"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["By default, Jest Lua tests complete once they reach the end of their execution. That means this test will ",(0,s.jsx)(t.em,{children:"not"})," work as intended:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"-- Don't do this!\ntest('the data is peanut butter', function()\n\tlocal function callback(error_, data)\n\t\tif error_ then\n\t\t\terror(error_)\n\t\tend\n\t\texpect(data).toBe('peanut butter')\n\tend\n\n\tfetchData(callback)\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The problem is that the test will complete as soon as ",(0,s.jsx)(t.code,{children:"fetchData"})," completes, before ever calling the callback."]}),"\n",(0,s.jsxs)(t.p,{children:["There is an alternate form of ",(0,s.jsx)(t.code,{children:"test"})," that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called ",(0,s.jsx)(t.code,{children:"done"}),", which is passed as a second parameter to the ",(0,s.jsx)(t.code,{children:"test"})," function. Jest Lua will wait until the ",(0,s.jsx)(t.code,{children:"done"})," callback is called before finishing the test."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"test('the data is peanut butter', function(_, done)\n\tlocal function callback(error_, data)\n\t\tif error_ then\n\t\t\tdone(error_)\n\t\t\treturn\n\t\tend\n\t\txpcall(function()\n\t\t\texpect(data).toBe('peanut butter')\n\t\t\tdone()\n\t\tend, function(err)\n\t\t\tdone(err)\n\t\tend)\n\tend\n\n\tfetchData(callback)\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If ",(0,s.jsx)(t.code,{children:"done()"})," is never called, the test will fail (with timeout error), which is what you want to happen."]}),"\n",(0,s.jsxs)(t.p,{children:["If the ",(0,s.jsx)(t.code,{children:"expect"})," statement fails, it throws an error and ",(0,s.jsx)(t.code,{children:"done()"})," is not called. If we want to see in the test log why it failed, we have to wrap ",(0,s.jsx)(t.code,{children:"expect"})," in a ",(0,s.jsx)(t.code,{children:"xpcall"})," block and pass the error in the error handler to ",(0,s.jsx)(t.code,{children:"done"}),". Otherwise, we end up with an opaque timeout error that doesn't show what value was received by ",(0,s.jsx)(t.code,{children:"expect(data)"}),"."]}),"\n",(0,s.jsx)(t.admonition,{type:"danger",children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"done()"})," should not be mixed with Promises in your tests."]})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var s=n(6540);const o={},a=s.createContext(o);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);