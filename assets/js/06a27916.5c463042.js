"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[997],{1581:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>r});var c=t(4848),o=t(8453);const a={id:"mock-functions",title:"Mock Functions"},s=void 0,l={id:"mock-functions",title:"Mock Functions",description:"Mock functions allow you to test the links between code by erasing the actual implementation of a function, capturing calls to the function (and the parameters passed in those calls), capturing instances of constructor functions when instantiated with new, and allowing test-time configuration of return values.",source:"@site/docs/MockFunctions.md",sourceDirName:".",slug:"/mock-functions",permalink:"/jest-lua/mock-functions",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"mock-functions",title:"Mock Functions"},sidebar:"docs",previous:{title:"Setup and Teardown",permalink:"/jest-lua/setup-teardown"},next:{title:"Snapshot Testing",permalink:"/jest-lua/snapshot-testing"}},i={},r=[{value:"Using a mock function",id:"using-a-mock-function",level:2},{value:"<code>.mock</code> property",id:"mock-property",level:2},{value:"Mock Return Values",id:"mock-return-values",level:2},{value:"Mock Implementations",id:"mock-implementations",level:2},{value:"Mock Names",id:"mock-names",level:2},{value:"Custom Matchers",id:"custom-matchers",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)("p",{children:(0,c.jsx)("a",{href:"https://jestjs.io/docs/27.x/mock-functions",target:"_blank",children:(0,c.jsx)("img",{alt:"Jest",src:"img/jestjs.svg"})})}),"\n",(0,c.jsxs)(n.p,{children:["Mock functions allow you to test the links between code by erasing the actual implementation of a function, capturing calls to the function (and the parameters passed in those calls), capturing instances of constructor functions when instantiated with ",(0,c.jsx)(n.code,{children:"new"}),", and allowing test-time configuration of return values."]}),"\n",(0,c.jsx)(n.h2,{id:"using-a-mock-function",children:"Using a mock function"}),"\n",(0,c.jsxs)(n.p,{children:["Let's imagine we're testing an implementation of a function ",(0,c.jsx)(n.code,{children:"forEach"}),", which invokes a callback for each item in a supplied array."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"local function forEach(items, callback)\n\tfor _, val in ipairs(items) do\n\t\tcallback(val)\n\tend\nend\n"})}),"\n",(0,c.jsx)(n.p,{children:"To test this function, we can use a mock function, and inspect the mock's state to ensure the callback is invoked as expected."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"local mockCallback = jest.fn()\nforEach({0, 1}, mockCallback)\n\n-- The mock function is called twice\nexpect(#mockCallback.mock.calls).toBe(2)\n\n-- The first argument of the first call to the function was 0\nexpect(mockCallback.mock.calls[1][1]).toBe(0)\n\n-- The first argument of the second call to the function was 1\nexpect(mockCallback.mock.calls[2][1]).toBe(1)\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"mock-property",children:[(0,c.jsx)(n.code,{children:".mock"})," property"]}),"\n",(0,c.jsxs)(n.p,{children:["All mock functions have this special ",(0,c.jsx)(n.code,{children:".mock"})," property, which is where data about how the function has been called and what the function returned is kept. The ",(0,c.jsx)(n.code,{children:".mock"})," property also tracks the value of ",(0,c.jsx)(n.code,{children:"self"})," for each call, so it is possible to inspect this as well:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"local myMock = jest.fn()\n\nlocal a = myMock.new()\nlocal b = myMock.new()\n\nexpect(myMock.mock.instances[1]).toBe(a)\nexpect(myMock.mock.instances[2]).toBe(b)\n"})}),"\n",(0,c.jsx)(n.p,{children:"These mock members are very useful in tests to assert how these functions get called, instantiated, or what they returned:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"-- The function was called exactly once\nexpect(#someMockFunction.mock.calls).toBe(1)\n\n-- The first arg of the first call to the function was 'first arg'\nexpect(someMockFunction.mock.calls[1][1]).toBe('first arg')\n\n-- The second arg of the first call to the function was 'second arg'\nexpect(someMockFunction.mock.calls[1][3]).toBe('second arg')\n\n-- The return value of the first call to the function was 'return value'\nexpect(someMockFunction.mock.results[1].value).toBe('return value')\n\n-- This function was instantiated exactly twice\nexpect(#someMockFunction.mock.instances).toBe(2)\n"})}),"\n",(0,c.jsx)(n.h2,{id:"mock-return-values",children:"Mock Return Values"}),"\n",(0,c.jsx)(n.p,{children:"Mock functions can also be used to inject test values into your code during a test:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"local myMock = jest.fn()\nprint(myMock()) -- > nil\n\nmyMock.mockReturnValueOnce(10).mockReturnValueOnce('x').mockReturnValue(true)\n\nprint(myMock()) -- > 10\nprint(myMock()) -- > 'x'\nprint(myMock()) -- > true\nprint(myMock()) -- > true\n"})}),"\n",(0,c.jsx)(n.p,{children:"Mock functions are also very effective in code that uses a functional continuation-passing style. Code written in this style helps avoid the need for complicated stubs that recreate the behavior of the real component they're standing in for, in favor of injecting values directly into the test right before they're used."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"local filterTestFn = jest.fn()\n\n-- Make the mock return `true` for the first call,\n-- and `false` for the second call\nfilterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false)\n\nlocal result = {}\n\nfor _, num in ipairs({11, 12}) do\n\tif filterTestFn(num) then\n\t\ttable.insert(result, num)\n\tend\nend\n\nprint(result) -- > {11}\nprint(filterTestFn.mock.calls) -- > {{11}, {12}}\n"})}),"\n",(0,c.jsx)(n.p,{children:"Most real-world examples actually involve getting ahold of a mock function on a dependent component and configuring that, but the technique is the same. In these cases, try to avoid the temptation to implement logic inside of any function that's not directly being tested."}),"\n",(0,c.jsx)(n.h2,{id:"mock-implementations",children:"Mock Implementations"}),"\n",(0,c.jsxs)(n.p,{children:["Still, there are cases where it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with ",(0,c.jsx)(n.code,{children:"jest.fn"})," or the ",(0,c.jsx)(n.code,{children:"mockImplementationOnce"})," method on mock functions."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"local myMockFn = jest.fn(function(cb) return cb(nil, true) end)\n\nmyMockFn(function(err, val) print(val) end) -- > true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the ",(0,c.jsx)(n.code,{children:"mockImplementationOnce"})," method:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"local myMockFn = jest.fn()\n\t.mockImplementationOnce(function(cb) return cb(nil, true) end)\n\t.mockImplementationOnce(function(cb) return cb(nil, false) end)\n\nmyMockFn(function(err, val) print(val) end) -- > true\nmyMockFn(function(err, val) print(val) end) -- > false\n"})}),"\n",(0,c.jsxs)(n.p,{children:["When the mocked function runs out of implementations defined with ",(0,c.jsx)(n.code,{children:"mockImplementationOnce"}),", it will execute the default implementation set with ",(0,c.jsx)(n.code,{children:"jest.fn"})," (if it is defined):"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"local myMockFn = jest.fn(function() return 'default' end)\n\t.mockImplementationOnce(function() return 'first call' end)\n\t.mockImplementationOnce(function() return 'second call' end)\n\nprint(myMockFn()) -- > 'first call'\nprint(myMockFn()) -- > 'second call'\nprint(myMockFn()) -- > 'default'\nprint(myMockFn()) -- > 'default\n"})}),"\n",(0,c.jsxs)(n.p,{children:["For cases where we have methods that are typically chained (and thus always need to return ",(0,c.jsx)(n.code,{children:"this"}),"), we have an API for this in the form of a ",(0,c.jsx)(n.code,{children:".mockReturnThis()"})," function that also sits on all mocks:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"local myObj = {\n\tmyMethod = jest.fn().mockReturnThis(),\n}\n"})}),"\n",(0,c.jsx)(n.h2,{id:"mock-names",children:"Mock Names"}),"\n",(0,c.jsx)(n.p,{children:'You can optionally provide a name for your mock functions, which will be displayed instead of "jest.fn()" in the test error output. Use this if you want to be able to quickly identify the mock function reporting an error in your test output.'}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"local myMockFn = jest.fn()\n\t.mockReturnValue('default')\n\t.mockName('onlyReturnsDefault')\n"})}),"\n",(0,c.jsx)(n.h2,{id:"custom-matchers",children:"Custom Matchers"}),"\n",(0,c.jsx)(n.p,{children:"Finally, in order to make it less demanding to assert how mock functions have been called, we've added some custom matcher functions for you:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"-- The mock function was called at least once\nexpect(mockFunc).toHaveBeenCalled()\n\n-- The mock function was called at least once with the specified args\nexpect(mockFunc).toHaveBeenCalledWith(arg1, arg2)\n\n-- The last call to the mock function was called with the specified args\nexpect(mockFunc).toHaveBeenLastCalledWith(arg1, arg2)\n"})}),"\n",(0,c.jsxs)(n.p,{children:["These matchers are sugar for common forms of inspecting the ",(0,c.jsx)(n.code,{children:".mock"})," property. You can always do this manually yourself if that's more to your taste or if you need to do something more specific:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-lua",children:"-- The mock function was called at least once\nexpect(#mockFunc.mock.calls).toBeGreaterThan(0)\n\n-- The mock function was called at least once with the specified args\nexpect(mockFunc.mock.calls).toContainEqual({arg1, arg2})\n\n-- The last call to the mock function was called with the specified args\nexpect(mockFunc.mock.calls[#mockFunc.mock.calls]).toEqual({\n\targ1,\n\targ2,\n})\n\n-- The first arg of the last call to the mock function was `42`\n-- (note that there is no sugar helper for this specific of an assertion)\nexpect(mockFunc.mock.calls[#mockFunc.mock.calls][1]).toBe(42)\n"})}),"\n",(0,c.jsxs)(n.p,{children:["For a complete list of matchers, check out the ",(0,c.jsx)(n.a,{href:"expect",children:"reference docs"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var c=t(6540);const o={},a=c.createContext(o);function s(e){const n=c.useContext(a);return c.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),c.createElement(a.Provider,{value:n},e.children)}}}]);