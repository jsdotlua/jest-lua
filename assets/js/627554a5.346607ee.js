"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[554],{868:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>l});var s=t(4848),i=t(8453);const c={id:"deviations",title:"Deviations"},o=void 0,a={id:"deviations",title:"Deviations",description:"The Jest Lua alignment effort aims to map as closely to Jest's API as possible, but there are a few places where language deviations require us to omit functionality or deviate our approach. Deviations are also sometimes made to maintain Lua-nativity. Any user-facing deviations are documented here.",source:"@site/docs/Deviations.md",sourceDirName:".",slug:"/deviations",permalink:"/jest-lua/deviations",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"deviations",title:"Deviations"},sidebar:"docs",previous:{title:"From v2.x to v3.x",permalink:"/jest-lua/upgrading-to-jest3"}},r={},l=[{value:"Globals",id:"globals",level:2},{value:"<code>.each</code>",id:"each",level:3},{value:"Expect",id:"expect",level:2},{value:"<code>.never</code>",id:"never",level:3},{value:"<code>expect.extend(matchers)</code>",id:"expectextendmatchers",level:3},{value:"<code>expect.any(typename | prototype)</code>",id:"expectanytypename--prototype",level:3},{value:"<code>expect.nothing()</code>",id:"expectnothing",level:3},{value:"<code>expect.stringMatching(string | regexp)</code>",id:"expectstringmatchingstring--regexp",level:3},{value:"<code>.toHaveLength(number)</code>",id:"tohavelengthnumber",level:3},{value:"<code>.toBeFalsy()</code>",id:"tobefalsy",level:3},{value:"<code>.toBeNil()</code>",id:"tobenil",level:3},{value:"<code>.toBeInstanceOf(prototype)</code>",id:"tobeinstanceofprototype",level:3},{value:"<code>.toMatch(string | regexp)</code>",id:"tomatchstring--regexp",level:3},{value:"<code>.toMatchInstance(table)</code>",id:"tomatchinstancetable",level:3},{value:"<code>.toStrictEqual()</code>",id:"tostrictequal",level:3},{value:"<code>.toThrow(error?)</code>",id:"tothrowerror",level:3},{value:"Mock Functions",id:"mock-functions",level:2},{value:"<code>jest.fn()</code>",id:"jestfn",level:3},{value:"<code>mockFn.new</code>",id:"mockfnnew",level:3},{value:"Fake Timers",id:"fake-timers",level:2},{value:"<code>jest.useFakeTimers()</code>",id:"jestusefaketimers",level:3},{value:"Configuration",id:"configuration",level:2},{value:"<code>projects</code>",id:"projects",level:3},{value:"Filters",id:"filters",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"The Jest Lua alignment effort aims to map as closely to Jest's API as possible, but there are a few places where language deviations require us to omit functionality or deviate our approach. Deviations are also sometimes made to maintain Lua-nativity. Any user-facing deviations are documented here."}),"\n",(0,s.jsx)(n.h2,{id:"globals",children:"Globals"}),"\n",(0,s.jsx)(n.h3,{id:"each",children:(0,s.jsx)(n.code,{children:".each"})}),"\n",(0,s.jsxs)(n.p,{children:["Tagged templates are not available in Lua. As an alternative, a list of tables can be passed into ",(0,s.jsx)(n.code,{children:"each"}),". First argument is a string with headings separated by |, or a table with a single element containing that."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"test.each('a | b | expected',\n\t{1, 1, 2},\n\t{1, 2, 3},\n\t{2, 1, 3}\n)('returns $expected when $a is added $b', function(ref)\n\tlocal a, b, expected = ref.a, ref.b, ref.expected\n\texpect(a + b).toBe(expected)\nend)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["An array of arrays can still be passed, see ",(0,s.jsx)(n.a,{href:"api#describeeachtablename-fn-timeout",children:(0,s.jsx)(n.code,{children:".each"})}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"expect",children:"Expect"}),"\n",(0,s.jsx)(n.h3,{id:"never",children:(0,s.jsx)(n.code,{children:".never"})}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"not"})," is a reserved keyword in Lua, Jest Lua uses ",(0,s.jsx)(n.code,{children:"never"})," to test the opposite of a matcher."]}),"\n",(0,s.jsx)(n.p,{children:"Some aliases are provided:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:".arrayNotContaining"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:".objectNotContaining"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:".stringNotContaining"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:".stringNotMatching"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"expectextendmatchers",children:(0,s.jsx)(n.code,{children:"expect.extend(matchers)"})}),"\n",(0,s.jsxs)(n.p,{children:["The first argument that a custom matcher takes in ",(0,s.jsx)(n.code,{children:"expect.extend(matchers)"})," always needs to be a ",(0,s.jsx)(n.code,{children:"self"}),", which is assigned the ",(0,s.jsx)(n.code,{children:"matcherContext"}),". It can be left empty with a ",(0,s.jsx)(n.code,{children:"_"})," if the ",(0,s.jsx)(n.code,{children:"matcherContext"})," is not needed. See the ",(0,s.jsx)(n.a,{href:"expect#custom-matchers-api",children:"Custom Matchers API doc"})," for more information."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"expect.extend({\n\tyourMatcher = function(self, y, z)\n\t\treturn {\n\t\t\tpass = true,\n\t\t\tmessage = function() return '' end\n\t\t}\n\tend\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expectanytypename--prototype",children:(0,s.jsx)(n.code,{children:"expect.any(typename | prototype)"})}),"\n",(0,s.jsxs)(n.p,{children:["Lua doesn't have constructors for primitive types, so ",(0,s.jsx)(n.code,{children:"expect.any"})," accepts either a typename string (e.g. ",(0,s.jsx)(n.code,{children:'"number"'}),", ",(0,s.jsx)(n.code,{children:'"boolean"'}),") or a table representing a prototype class."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If a typename string is passed in, it checks that the received value has the ",(0,s.jsx)(n.code,{children:"typeof()"})," value as the expected string"]}),"\n",(0,s.jsxs)(n.li,{children:["If a table is passed in, it checks that the received value in is an instance (or a derived instance) of the expected table, using the ",(0,s.jsxs)(n.a,{href:"https://github.com/Roblox/luau-polyfill/blob/main/src/instanceof.lua",children:[(0,s.jsx)(n.code,{children:"instanceof"})," method in LuauPolyfill"]})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"expectnothing",children:(0,s.jsx)(n.code,{children:"expect.nothing()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.nothing"})," allows for matching against nil and undefined values. You can use it inside ",(0,s.jsx)(n.code,{children:"toMatchObject"})," and other similar matchers to ensure something is undefined or ",(0,s.jsx)(n.code,{children:"nil"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"expectstringmatchingstring--regexp",children:(0,s.jsx)(n.code,{children:"expect.stringMatching(string | regexp)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"expect.stringMatching(string | regexp)"})," can either accept a ",(0,s.jsx)(n.a,{href:"https://developer.roblox.com/en-us/articles/string-patterns-reference",children:"Lua string pattern"})," or a ",(0,s.jsx)(n.a,{href:"expect#regexp",children:"RegExp"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"tohavelengthnumber",children:(0,s.jsx)(n.code,{children:".toHaveLength(number)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toHaveLength(number)"})," uses the Lua ",(0,s.jsx)(n.code,{children:"#"})," operator to check the length of the received value. Since ",(0,s.jsx)(n.code,{children:"#"})," is only well defined for non-sparse array-like tables and strings it will return 0 for tables with key-value pairs. It also checks the ",(0,s.jsx)(n.code,{children:".length"})," property of the table instead if it has one."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toHaveLength"})," ",(0,s.jsx)(n.strong,{children:"cannot"})," be used to check the argument count of a function."]}),"\n",(0,s.jsx)(n.h3,{id:"tobefalsy",children:(0,s.jsx)(n.code,{children:".toBeFalsy()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toBeFalsy()"})," checks for Lua falsy values, which are only ",(0,s.jsx)(n.code,{children:"false"})," and ",(0,s.jsx)(n.code,{children:"nil"}),". That means that unlike in Javscript, ",(0,s.jsx)(n.code,{children:"expect(0).toBeFalsy()"})," ",(0,s.jsx)(n.strong,{children:"does not"})," pass. Consequently, ",(0,s.jsx)(n.code,{children:".toBeTruthy()"})," matches anything that isn't ",(0,s.jsx)(n.code,{children:"false"})," or ",(0,s.jsx)(n.code,{children:"nil"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"tobenil",children:(0,s.jsx)(n.code,{children:".toBeNil()"})}),"\n",(0,s.jsxs)(n.p,{children:["When doing ",(0,s.jsx)(n.code,{children:"nil"})," checking, use of ",(0,s.jsx)(n.code,{children:".toBeNil()"})," and ",(0,s.jsx)(n.code,{children:".never.toBeNil()"})," is encouraged to maintain Lua syntax. The following methods are identical but provided for the sake of completeness:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".toBeUndefined()"})," is identical to ",(0,s.jsx)(n.code,{children:".toBeNil()"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".toBeDefined()"})," is identical to ",(0,s.jsx)(n.code,{children:".never.toBeNil()"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".toBeNull()"})," is an alias of ",(0,s.jsx)(n.code,{children:".toBeNil()"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tobeinstanceofprototype",children:(0,s.jsx)(n.code,{children:".toBeInstanceOf(prototype)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toBeInstanceOf(prototype)"})," uses the ",(0,s.jsxs)(n.a,{href:"https://github.com/Roblox/luau-polyfill/blob/main/src/instanceof.lua",children:[(0,s.jsx)(n.code,{children:"instanceof"})," method in LuauPolyfill"]})," to check that a value is an instance (or a derived instance) of a prototype class."]}),"\n",(0,s.jsx)(n.h3,{id:"tomatchstring--regexp",children:(0,s.jsx)(n.code,{children:".toMatch(string | regexp)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toMatch"})," matches a ",(0,s.jsx)(n.a,{href:"https://developer.roblox.com/en-us/articles/string-patterns-reference",children:"Lua string pattern"})," or a ",(0,s.jsx)(n.a,{href:"expect#regexp",children:"Regexp"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"tomatchinstancetable",children:(0,s.jsx)(n.code,{children:".toMatchInstance(table)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toMatchInstance"})," is custom matcher unique to Jest Lua that allows for matching a Roblox Instance against a table of properties."]}),"\n",(0,s.jsx)(n.h3,{id:"tostrictequal",children:(0,s.jsx)(n.code,{children:".toStrictEqual()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"toStrictEqual()"})," performs a ",(0,s.jsx)(n.code,{children:"toEqual"})," comparison with an additional type/class check based on metatable inheritance. Our ",(0,s.jsx)(n.code,{children:"toStrictEqual"})," does not check for array sparseness or for ",(0,s.jsx)(n.code,{children:"undefined"})," values like the matcher does in Javascript's Jest."]}),"\n",(0,s.jsx)(n.h3,{id:"tothrowerror",children:(0,s.jsx)(n.code,{children:".toThrow(error?)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:".toThrow(error?)"})," can also accept custom Error objects provided by LuauPolyfill."]}),"\n",(0,s.jsx)(n.h2,{id:"mock-functions",children:"Mock Functions"}),"\n",(0,s.jsx)(n.h3,{id:"jestfn",children:(0,s.jsx)(n.code,{children:"jest.fn()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"jest.fn()"})," returns two values. The first return value is the mock object, which is a callable table and ",(0,s.jsx)(n.em,{children:"can"})," be treated as a mock function if the tested code accepts a callable table as being interchangeable with a function."]}),"\n",(0,s.jsxs)(n.p,{children:["For cases where the tested code requires a function, pass in the second return value of ",(0,s.jsx)(n.code,{children:"jest.fn()"}),", which is a forwarding function that calls the mock."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"local mock, mockFn = jest.fn()\nmockFn()\nexpect(mock).toHaveBeenCalled()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note that this remains backward compatible with Jest tests translated from JavaScript, since the second argument will be dropped if not explicitly assigned."}),"\n",(0,s.jsx)(n.h3,{id:"mockfnnew",children:(0,s.jsx)(n.code,{children:"mockFn.new"})}),"\n",(0,s.jsxs)(n.p,{children:["Our translation of ",(0,s.jsx)(n.code,{children:"new mockFn()"})," in Javascript is ",(0,s.jsx)(n.code,{children:"mockFn.new()"})]}),"\n",(0,s.jsx)(n.p,{children:"So for the following code pattern in Javascript:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const mockFn = jest.fn()\nconst instance1 = new mockFn()\n"})}),"\n",(0,s.jsx)(n.p,{children:"We would write it in Lua as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"local mockFn = jest.fn()\nlocal instance1 = mockFn.new()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"fake-timers",children:"Fake Timers"}),"\n",(0,s.jsx)(n.h3,{id:"jestusefaketimers",children:(0,s.jsx)(n.code,{children:"jest.useFakeTimers()"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"jest.useFakeTimers()"})," injects fake versions of Lua and Roblox timers."]}),"\n",(0,s.jsxs)(n.p,{children:["The supported timers are ",(0,s.jsx)(n.code,{children:"delay"}),", ",(0,s.jsx)(n.code,{children:"tick"}),", ",(0,s.jsx)(n.code,{children:"time"}),", ",(0,s.jsx)(n.code,{children:"DateTime"}),", ",(0,s.jsx)(n.code,{children:"task.delay"}),", ",(0,s.jsx)(n.code,{children:"os.time"}),", and ",(0,s.jsx)(n.code,{children:"os.clock"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"projects",children:(0,s.jsx)(n.code,{children:"projects"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"projects"})," configuration takes an array of Instances. Each entry should be a path to a datamodel Instance with a configuration file."]}),"\n",(0,s.jsx)(n.h3,{id:"filters",children:"Filters"}),"\n",(0,s.jsxs)(n.p,{children:["Test filtering configuration options like ",(0,s.jsx)(n.code,{children:"testMatch"})," or ",(0,s.jsx)(n.code,{children:"testPathIgnorePatterns"})," match against the path of the test in the datamodel, not the filesystem path."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},c=s.createContext(i);function o(e){const n=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);